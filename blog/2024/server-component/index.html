<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Undterstand Server Component | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/server-component/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Undterstand Server Component</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <p>Here will talk from the point of Next.js.</p> <p>In Next.js, all components in the App Router are Server Components <strong>by default</strong>!</p> <p>Router is the skeleton of the whole Next.js Application. It can decide <strong>HOW</strong> to render Server Components and Client Components.</p> <h2 id="foundational-web-concepts">Foundational web concepts</h2> <ul> <li>The <strong>Environments</strong> your application code can be executed in: the server and the client.</li> <li>The <strong>Request-Response Lifecycle</strong> that’s initiated when a user visits or interacts with your application.</li> <li>The <strong>Network Boundary</strong> that separates server and client code.</li> </ul> <h3 id="rendering-environments">Rendering Environments</h3> <p>There are two environments where web applications can be rendered: the client and the server.</p> <p>Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use the same language (JavaScript), and the same framework (e.g. Next.js or your framework of choice). This flexibility allows you to seamlessly write code for both environments without context switching.</p> <p>However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is not always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment over the other.</p> <h3 id="network-boundary">Network Boundary</h3> <p>In web development, the Network Boundary is a conceptual line that separates the different environments. For example, the client and the server, or the server and the data store.</p> <p>In React, you choose where to place the client-server network boundary wherever it makes the most sense.</p> <p>Behind the scenes, the work is split into two parts: the client module graph and the server module graph. The server module graph contains all the components that are rendered on the server, and the client module graph contains all components that are rendered on the client.</p> <p>It may be helpful to think about module graphs as a visual representation of how files in your application depend on each other.</p> <p>You can use the React <code class="language-plaintext highlighter-rouge">"use client"</code> convention to define the boundary. There’s also a <code class="language-plaintext highlighter-rouge">"use server"</code> convention, which tells React to do some computational work on the server.</p> <h3 id="building-hybrid-applications">Building Hybrid Applications</h3> <p>When working in these environments, it’s helpful to think of the flow of the code in your application as <strong>unidirectional</strong>. If you need to access the server from the client, you send a new request to the server rather than re-use the same request. This makes it easier to understand where to render your components and where to place the Network Boundary.</p> <p>In practice, this model encourages developers to think about what they want to execute on the server first, before sending the result to the client and making the application interactive.</p> <h2 id="react-server-components">React Server Components</h2> <h3 id="server-rendering">Server Rendering</h3> <p>React Server Components allow you to write UI that can be rendered and optionally cached on the server. In short, Server Components allow you to do <strong>Server Rendering</strong>.</p> <h4 id="benefits-of-server-rendering">Benefits of Server Rendering</h4> <ul> <li>Data Fetching: Server Components allow you to move data fetching to the server.</li> <li>Security: Server Components allow you to keep sensitive data and logic on the server.</li> <li>Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users.</li> <li>Performance: Server Components give you additional tools to optimize performance.</li> <li>Initial Page Load and First Contentful Paint (FCP).</li> <li>Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots.</li> <li>Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.</li> </ul> <h3 id="how-are-server-components-rendered-in-nextjs">How are Server Components rendered in Next.js</h3> <p>Next.js uses Server Components by default. This allows you to automatically implement server rendering with no additional configuration, and you can opt into using Client Components when needed.</p> <p>On the server, Next.js uses React’s APIs to orchestrate rendering. The rendering work is split into chunks:</p> <ul> <li>by individual route segments and</li> <li>Suspense Boundaries.</li> </ul> <p>Each chunk is rendered in two steps:</p> <ol> <li>React renders Server Components into a special data format called the React Server Component Payload (<strong>RSC Payload</strong>).</li> <li>Next.js uses the RSC Payload and Client Component JavaScript instructions to render HTML on the server.</li> </ol> <p>Then, on the client:</p> <ol> <li>The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.</li> <li>The RSC Payload is used to reconcile the Client and Server Component trees, and update the DOM.</li> <li>The JavaScript instructions are used to <strong>hydrate</strong> Client Components and make the application interactive.</li> </ol> <h3 id="what-is-hydration">What is Hydration</h3> <p>In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.</p> <p>For example, Call <code class="language-plaintext highlighter-rouge">hydrate</code> to attach a React component into a server-rendered browser DOM node:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">hydrate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-dom</span><span class="dl">'</span><span class="p">;</span>
<span class="nf">hydrate</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">App</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div></div> <h3 id="what-is-the-react-server-component-payload-rsc-payload">What is the React Server Component Payload (RSC Payload)?</h3> <p>The RSC Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the client to update the browser’s DOM. The RSC Payload contains:</p> <ul> <li>The rendered result of Server Components</li> <li>Placeholders for where Client Components should be rendered and references to their JavaScript files</li> <li>Any props passed from a Server Component to a Client Component</li> </ul> <h3 id="server-rendering-strategies">Server rendering strategies</h3> <p>In Next.js, the rendering work is further split by route segments to enable streaming and partial rendering.</p> <p>There are three subsets of server rendering: Static, Dynamic, and Streaming.</p> <h4 id="static-rendering-default">Static Rendering (Default)</h4> <p>With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests.</p> <h4 id="dynamic-rendering">Dynamic Rendering</h4> <p>With Dynamic Rendering, routes are rendered for each user at request time.</p> <p>Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL’s search params.</p> <p>In most websites, routes are not fully static or fully dynamic - it’s a spectrum.</p> <p>In Next.js, you can have dynamically rendered routes that have both cached and uncached data. This is because the RSC Payload and data are cached separately. This allows you to opt into dynamic rendering without worrying about the performance impact of fetching all the data at request time.</p> <p>During rendering, if a <code class="language-plaintext highlighter-rouge">dynamic function</code> or <code class="language-plaintext highlighter-rouge">uncached data request</code> is discovered, Next.js will switch to dynamically rendering the whole route.</p> <p>In Next.js, these dynamic functions are:</p> <ul> <li>cookies() and headers(): Using these in a Server Component will opt the whole route into dynamic rendering at request time.</li> <li>searchParams: Using the searchParams prop on a Page will opt the page into dynamic rendering at request time.</li> </ul> <h4 id="streaming">Streaming</h4> <p>Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.</p> <p>Streaming is built into the Next.js App Router by default. This helps improve both the initial page loading performance, as well as UI that depends on slower data fetches that would block rendering the whole route.</p> <h3 id="use-server-component">Use Server component</h3> <ul> <li>You don’t need to use <code class="language-plaintext highlighter-rouge">"use server"</code> to write Server component. Just ust <code class="language-plaintext highlighter-rouge">"use server"</code> to export server atction.</li> </ul> <h2 id="client-components">Client Components</h2> <p>Client Components allow you to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser.</p> <h3 id="client-rendering">Client Rendering</h3> <p>Benefits of Client Rendering</p> <ul> <li>Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.</li> <li>Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage.</li> </ul> <h3 id="using-client-components">Using Client Components</h3> <p>To use Client Components, you can add the React <code class="language-plaintext highlighter-rouge">"use client"</code> directive at the top of a file, above your <code class="language-plaintext highlighter-rouge">imports</code>.</p> <p><code class="language-plaintext highlighter-rouge">"use client"</code> is used to declare a boundary between a Server and Client Component modules. This means that by defining a <code class="language-plaintext highlighter-rouge">"use client"</code> in a file, all other modules imported into it, including child components, are considered part of the client bundle.</p> <p>You can define multiple <code class="language-plaintext highlighter-rouge">"use client"</code> <strong>entry points</strong> in your React Component tree. This allows you to split your application into multiple client bundles.</p> <p>However, <code class="language-plaintext highlighter-rouge">"use client"</code> doesn’t need to be defined in every component that needs to be rendered on the client. For example, when you import a component into a client component, that component will be treated as client component. Once you define the boundary, all child components and modules imported into it are considered part of the client bundle.</p> <blockquote class="block-warning"> <p>All components are considered as Server components first until you use <code class="language-plaintext highlighter-rouge">"use client"</code> to define the boundary. You should have a clear mind when you define the boundary because the client components are the less the better.</p> </blockquote> <h4 id="recap">Recap</h4> <ul> <li>Once you define the boundary, all child components and modules <strong>imported</strong> into it are considered part of the client bundle. But Server component can live inside Client component as <strong>children</strong>. The classic example is that context component, which can be client component, can wrap server component.</li> <li>All hooks, state management (Context API, Zustand, Redux) just use in Client components.</li> <li> <code class="language-plaintext highlighter-rouge">async/await </code>is not support in client components, only in server components in Next.js.</li> <li>client components don’t just run in the client. They will run once in the server for the initial rendering! So if you visit Browser API, like <code class="language-plaintext highlighter-rouge">localStorage</code>, you may get errors. So it is better to use code like this: <code class="language-plaintext highlighter-rouge">if (typeof(window !=== undefined)) { window.localStorage()...}</code> to protect it. React won’t run hook in initial rendering because React know that things.</li> <li>In server component, if you use a component which use Hooks or Browser API, and that component don’t use <code class="language-plaintext highlighter-rouge">"use client"</code>, it will cause errors. In this case, you just need to add <code class="language-plaintext highlighter-rouge">'use client'</code>. If that component is 3rd lib, you can wrap it in a separate component and add <code class="language-plaintext highlighter-rouge">'use client'</code>.</li> </ul> <h3 id="how-are-client-components-rendered">How are Client Components Rendered</h3> <p>There can be two ways:</p> <ul> <li>Full page load: To optimize the initial page load, Next.js will use React’s APIs to render a static HTML preview on the server for both Client and Server Components. And then React will do a process which is called <strong>hydration</strong>.</li> <li>Subsequent Navigations: Client Components are rendered entirely on the client, without the server-rendered HTML.</li> </ul> <h3 id="going-back-to-the-server-environment">Going back to the Server Environment</h3> <p>Sometimes, after you’ve declared the “use client” boundary, you may want to go back to the server environment.</p> <p>You can keep code on the server even though it’s theoretically nested inside Client Components by <strong>interleaving</strong> Client and Server Components and Server Actions.</p> <h2 id="composition-patterns">Composition Patterns</h2> <p>Need to have a clear mind what server component, client component should do, and can do! Use Server Component when:</p> <ul> <li>Fetch data</li> <li>Access backend resources (directly)</li> <li>Keep sensitive information on the server (access tokens, API keys, etc)</li> <li>Keep large dependencies on the server / Reduce client-side JavaScript</li> </ul> <p>Use Client Component when:</p> <ul> <li>Add interactivity and event listeners (onClick(), onChange(), etc)</li> <li>Use State and Lifecycle Effects (useState(), useReducer(), useEffect(), etc)</li> <li>Use browser-only APIs</li> <li>Use custom hooks that depend on state, effects, or browser-only APIs</li> </ul> <h3 id="server-component-patterns">Server Component Patterns</h3> <p>Here are some common patterns when working with Server Components:</p> <h4 id="sharing-data-between-components">Sharing data between components</h4> <p>Instead of using React Context or passing data as props, you can use <code class="language-plaintext highlighter-rouge">fetch</code> or React’s <code class="language-plaintext highlighter-rouge">cache</code> function to fetch the same data in the components. React extends <code class="language-plaintext highlighter-rouge">fetch</code> to automatically memoize data requests.</p> <h4 id="keeping-server-only-code-out-of-the-client-environment">Keeping Server-only Code out of the Client Environment</h4> <p>You may keep some module just only available for server component. For example, the component is using some sensitive data, like <code class="language-plaintext highlighter-rouge">API_KEY</code>, to fetch data. You can use <code class="language-plaintext highlighter-rouge">import 'server-only'</code> to give other developers a build-time error if they ever accidentally import one of these modules into a Client Component.</p> <h4 id="using-third-party-packages-and-providers">Using Third-party Packages and Providers</h4> <p>When you use Third-party Packages in your server component, and these Packages are using some Client only API, you will get some error. The simply way to fix this error is telling Next.js that, this part of code is render as client component by wrap it into a file with <code class="language-plaintext highlighter-rouge">"use client"</code>.</p> <p>When use Context Providers in your server component, it is same way to deal with it: mark it as a Client Component: Wrap these Providers into a file with <code class="language-plaintext highlighter-rouge">"use client"</code>.</p> <h3 id="client-components-patterns">Client Components Patterns</h3> <p>To reduce the Client JavaScript bundle size, Next.js recommend moving Client Components down your component tree. That means try to keep all your components as server components if it can be.</p> <h4 id="passing-props-from-server-to-client-components-serialization">Passing props from Server to Client Components (Serialization)</h4> <p>If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to be serializable by React.</p> <p>If your Client Components depend on data that is not serializable, you can fetch data on the client with a third party library or on the server via a Route Handler.</p> <h3 id="interleaving-patterns">Interleaving Patterns</h3> <p>You should visualize your UI as a tree of components. Starting with the root layout, which is a Server Component, you can then render certain subtrees of components on the client by adding the “use client” directive.</p> <p>Within those client subtrees, you can still nest Server Components or call Server Actions, however there are some things to keep in mind:</p> <ul> <li>During a request-response lifecycle, your code moves from the server to the client. If you need to access data or resources on the server while on the client, you’ll be making a new request to the server - not switching back and forth.</li> <li>When a new request is made to the server, all Server Components are rendered first, including those nested inside Client Components. The rendered result (RSC Payload) will contain references to the locations of Client Components. Then, on the client, React uses the RSC Payload to reconcile Server and Client Components into a single tree.</li> <li>Since Client Components are rendered after Server Components, you cannot import a Server Component into a Client Component module (since it would require a new request back to the server). Instead, you can pass a Server Component as props to a Client Component.</li> </ul> <blockquote class="block-warning"> <p>The pattern of “lifting content up” has been used to avoid re-rendering a nested child component when a parent component re-renders.</p> </blockquote> <h2 id="fqa">FQA</h2> <ul> <li>How do Server and Client component communicate? What kind of protocal? and How?</li> <li>How do React know a component is Server component or Client component?</li> <li>How do Next.js know what codes need to be bundle and send to browser when Client and Server Components are interleaving together?</li> <li>How do React and Next.js connect together?</li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Apr 4, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/react"> <i class="fas fa-tag fa-sm"></i> React</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/next-js"> <div class="tag"> Next.js </div> </a> <a href="/blog/tag/router"> <div class="tag"> Router </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#foundational-web-concepts"> # Foundational web concepts </a> </div> <div class="toc-item"> <a href="#react-server-components"> # React Server Components </a> </div> <div class="toc-item"> <a href="#client-components"> # Client Components </a> </div> <div class="toc-item"> <a href="#composition-patterns"> # Composition Patterns </a> </div> <div class="toc-item"> <a href="#server-component-patterns">     # Server Component Patterns </a> </div> <div class="toc-item"> <a href="#client-components-patterns">     # Client Components Patterns </a> </div> <div class="toc-item"> <a href="#interleaving-patterns">     # Interleaving Patterns </a> </div> <div class="toc-item"> <a href="#fqa"> # FQA </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>