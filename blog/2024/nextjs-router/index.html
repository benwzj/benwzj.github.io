<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Next.js App Router Introduction | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/nextjs-router/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Next.js App Router Introduction</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <h2 id="what-is-routing">What is Routing</h2> <p>Routing is the skeleton of every web application. It is refer to the structure of files and URL.</p> <figure> <picture> <img src="/assets/img/terminology-component-tree.avif" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <img src="/assets/img/terminology-url-anatomy.avif" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="app-route-vs-page-route">App Route vs Page Route</h2> <ul> <li>Next.js doc divided into two parts: App Route and Page Route.</li> <li>In version 13, Next.js introduced App Router built on React Server Components, which supports shared layouts, nested routing, loading states, error handling, and more. New Project should use App Route.</li> <li>The App Router works in a directory named <code class="language-plaintext highlighter-rouge">app</code>. The Page Route works in a <code class="language-plaintext highlighter-rouge">pages</code> directory. They can work at the same time.</li> <li>App Route structure: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>└── app
  ├── about
  │   └── page.tsx
  ├── globals.css
  ├── layout.tsx
  ├── login
  │   └── page.tsx
  ├── page.js 
  └── team
      └── route.tsx
</code></pre></div> </div> </li> <li>Page Route structure: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>└── pages
  ├── about.tsx
  ├── index.tsx
  └── team.tsx
</code></pre></div> </div> </li> <li>In App Route, Components is Server Components by default; In Page Route, component is Client Components by default.</li> <li>In App Route, <code class="language-plaintext highlighter-rouge">fetch</code> function for data fetching; In Page Route, It is using <code class="language-plaintext highlighter-rouge">getServerSideProps</code>, <code class="language-plaintext highlighter-rouge">getStaticProps</code>, <code class="language-plaintext highlighter-rouge">getInitialProps</code>.</li> <li>In App Route, Layouts can be nested and dynamic; In Page Route, Layouts are static.</li> </ul> <h3 id="this-two-models-are-foundationally-different">This two models are foundationally different</h3> <ul> <li>In the page router model, you write code the client components, everything is in the client components. For example you have a <code class="language-plaintext highlighter-rouge">event_handler</code> that will call <code class="language-plaintext highlighter-rouge">API route</code> which update some resource in server, and then that API route return some JSON to the client, and the client will handle the JSON and update the UI.</li> <li>App router is totally server based! Form submit Server action, and server can update resource, revalidate cache, and return new UI data.</li> </ul> <figure> <picture> <img src="/assets/img/app_page_router.png" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="app-route-basic">App Route Basic</h2> <h3 id="file-conventions">File Conventions</h3> <p>Next.js provides a set of special files to create UI with specific behavior in nested routes:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">layout</code> Shared UI for a segment and its children</li> <li> <code class="language-plaintext highlighter-rouge">page</code> Unique UI of a route and make routes publicly accessible</li> <li> <code class="language-plaintext highlighter-rouge">loading</code> Loading UI for a segment and its children</li> <li> <code class="language-plaintext highlighter-rouge">not-found</code> Not found UI for a segment and its children</li> <li> <code class="language-plaintext highlighter-rouge">error</code> Error UI for a segment and its children</li> <li> <code class="language-plaintext highlighter-rouge">global-error</code> Global Error UI</li> <li> <code class="language-plaintext highlighter-rouge">route</code> Server-side API endpoint</li> <li> <code class="language-plaintext highlighter-rouge">template</code> Specialized re-rendered Layout UI</li> <li> <code class="language-plaintext highlighter-rouge">default</code> Fallback UI for Parallel Routes</li> </ul> <h3 id="component-hierarchy">Component Hierarchy</h3> <p>The React components defined in special files of a route segment are rendered in a specific hierarchy:</p> <ul> <li>layout.js</li> <li>template.js</li> <li>error.js (React error boundary)</li> <li>loading.js (React suspense boundary)</li> <li>not-found.js (React error boundary)</li> <li>page.js or nested layout.js</li> </ul> <h3 id="page">Page</h3> <ul> <li>A <code class="language-plaintext highlighter-rouge">page.js</code> file is required to make a route segment publicly accessible.</li> <li>A page is UI that is unique to a route. You can define a page by default exporting a component from a <code class="language-plaintext highlighter-rouge">page.js</code> file.</li> <li>Pages are Server Components by default, but can be set to a Client Component.</li> <li>Pages can fetch data.</li> </ul> <h3 id="layout">Layout</h3> <ul> <li>A layout is UI that is <strong>shared</strong> between multiple routes. (HOW? the page at the same folder and all the subfolder pages share the layout!)</li> <li>On navigation, layouts preserve state, remain interactive, and do not re-render.</li> <li>You can define a layout by default exporting a React component from a <code class="language-plaintext highlighter-rouge">layout.js</code> file. The component should accept a <code class="language-plaintext highlighter-rouge">children</code> prop that will be populated with a child layout (if it exists) or a page during rendering.</li> <li>Root Layout (Required)</li> <li>Nesting Layouts, By default, layouts in the folder hierarchy are nested, which means they wrap child layouts via their children prop.</li> <li>Layouts are Server Components by default but can be set to a Client Component.</li> <li>Passing data between a parent layout and its children is <strong>NOT</strong> possible. However, you can fetch the same data in a route more than once, and React will automatically dedupe the requests without affecting performance.</li> <li>Layouts do not have access to the route segments below itself. To access all route segments, you can use <code class="language-plaintext highlighter-rouge">useSelectedLayoutSegment</code> or <code class="language-plaintext highlighter-rouge">useSelectedLayoutSegments</code> in a Client Component.</li> <li>You can use <code class="language-plaintext highlighter-rouge">Route Groups</code> to opt specific route segments in and out of shared layouts.</li> <li>You can use <code class="language-plaintext highlighter-rouge">Route Groups</code> to create multiple root layouts.</li> </ul> <h3 id="templates">Templates</h3> <ul> <li>Templates are similar to layouts in that they wrap each child layout or page.</li> <li> <p>Unlike layouts that persist across routes and maintain state, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes that share a template, a new instance of the component is mounted, DOM elements are recreated, state is not preserved, and effects are re-synchronized.</p> </li> <li>Templates would be a more suitable option than layouts at below situations: <ul> <li>Features that rely on useEffect (e.g logging page views) and useState (e.g a per-page feedback form).</li> <li>To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time the Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation.</li> </ul> </li> </ul> <h3 id="metadata">Metadata</h3> <p>In the app directory, you can modify the <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> HTML elements such as title and meta using the Metadata APIs.</p> <h2 id="navigation">Navigation</h2> <p><a href="https://nextjs.org/docs/app/building-your-application/routing" rel="external nofollow noopener" target="_blank">Next.js Doc</a></p> <h3 id="4-ways-to-navigate-between-routes">4 ways to navigate between routes</h3> <ul> <li>Using the <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> Component: <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> is a built-in component that extends the HTML <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> tag to provide prefetching and client-side navigation between routes. It is the primary and recommended way to navigate between routes in Next.js. <ul> <li>Linking to Dynamic Segments: <code class="language-plaintext highlighter-rouge">&lt;Link href={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;</code> </li> <li>Checking Active Links: <code class="language-plaintext highlighter-rouge">usePathname()</code> to determine if a link is active.</li> </ul> </li> <li>Using the <code class="language-plaintext highlighter-rouge">useRouter</code> hook (Client Components)</li> <li>Using the <code class="language-plaintext highlighter-rouge">redirect</code> function (Server Components)</li> <li>Using the native History API: Next.js allows you to use the native <code class="language-plaintext highlighter-rouge">window.history.pushState</code> and <code class="language-plaintext highlighter-rouge">window.history.replaceState</code> methods to update the browser’s history stack without reloading the page. These APIs integrate into the Next.js Router, allowing you to sync with <code class="language-plaintext highlighter-rouge">usePathname</code> and <code class="language-plaintext highlighter-rouge">useSearchParams</code>.</li> </ul> <h3 id="how-routing-and-navigation-works">How Routing and Navigation Works</h3> <p>The App Router uses a hybrid approach for routing and navigation.</p> <ul> <li>On the server, your application code is automatically <strong>code-split</strong> by route segments.</li> <li>On the client, Next.js <strong>prefetches</strong> and <strong>caches</strong> the route segments. This means, when a user navigates to a new route, the browser doesn’t reload the page, and only the route segments that change re-render - improving the navigation experience and performance.</li> <li>Also support Partial Rendering, Soft Navigation, Back and Forward Navigation, Routing between <code class="language-plaintext highlighter-rouge">pages/</code> and <code class="language-plaintext highlighter-rouge">app/</code> </li> </ul> <h2 id="streaming">Streaming</h2> <h3 id="what-is-streaming">What is Streaming</h3> <p>Streaming is a data transfer technique that allows you to break down a route into smaller “chunks” and progressively stream them from the server to the client as they become ready.</p> <p>There are two ways you implement streaming in Next.js:</p> <ul> <li>At the page level, with the <code class="language-plaintext highlighter-rouge">loading.tsx</code> file.</li> <li>For specific components, with <code class="language-plaintext highlighter-rouge">&lt;Suspense&gt;</code>.</li> </ul> <h3 id="streaming-features">Streaming Features</h3> <ul> <li>Streaming is an advanced method of Server Side Rendering.</li> <li>Streaming allows you to break down the page’s HTML into smaller chunks and progressively send those chunks from the server to the client.</li> <li>Streaming implement Partial Rendering.</li> <li>By streaming, you can prevent slow data requests from blocking your whole page. This allows the user to see and interact with parts of the page without waiting for all the data to load before any UI can be shown to the user.</li> <li>Streaming works well with React’s component model because each component can be considered a chunk.</li> </ul> <h3 id="streaming-a-whole-page-with-loadingtsx">Streaming a whole page with <code class="language-plaintext highlighter-rouge">loading.tsx</code> </h3> <p><code class="language-plaintext highlighter-rouge">loading.tsx</code> is a special Next.js file built on top of <strong>Suspense</strong>, it allows you to create fallback UI to show as a replacement while page content loads. <code class="language-plaintext highlighter-rouge">loading.tsx</code> is describing the fallback UI which should be a static rendering.</p> <p>To use Streaming with <code class="language-plaintext highlighter-rouge">loading.tsx</code>, the <code class="language-plaintext highlighter-rouge">loading.tsx</code> file is located at same folder level with <code class="language-plaintext highlighter-rouge">page.tsx</code>. Next.js will display <code class="language-plaintext highlighter-rouge">loading.tsx</code> first, then the <code class="language-plaintext highlighter-rouge">page.tsx</code>.</p> <p>Also, The user doesn’t have to wait for the page to finish loading before navigating away. (this is called interruptable navigation).</p> <p>When you use <code class="language-plaintext highlighter-rouge">loading.tsx</code>, usually you use Route Groups as well.</p> <h4 id="route-groups-concept">Route Groups Concept</h4> <p>When <code class="language-plaintext highlighter-rouge">loading.tsx</code> is a level higher than <code class="language-plaintext highlighter-rouge">/subfolder/page.tsx</code> in the file system, it’s also applied to that page. In order to fix this problem. Next.js use route groups concept: Create a new folder called <code class="language-plaintext highlighter-rouge">/(overview)</code> inside the dashboard folder. Then, move your <code class="language-plaintext highlighter-rouge">loading.tsx</code> and <code class="language-plaintext highlighter-rouge">page.tsx</code> files inside the folder. Now, the <code class="language-plaintext highlighter-rouge">loading.tsx</code> file will only apply to the same folder level page.</p> <blockquote> <p>When you create a new folder using parentheses <code class="language-plaintext highlighter-rouge">()</code>, the name won’t be included in the URL path.</p> </blockquote> <h3 id="streaming-a-component-with-suspense">Streaming a component with <code class="language-plaintext highlighter-rouge">&lt;Suspense&gt;</code> </h3> <p>Wrap the component which need to be Streaming into <code class="language-plaintext highlighter-rouge">&lt;Suspense&gt;</code>.</p> <p>Suspense allows you to defer rendering parts of your application until some condition is met (e.g. data is loaded). You can wrap your dynamic components in Suspense. Then, pass it a fallback component to show while the dynamic component loads.</p> <p>Steps:</p> <ul> <li>Move data fetching down to the component that need it, thus isolating which parts of your routes should be dynamic in preparation for Partial Prerendering.</li> <li>Using <code class="language-plaintext highlighter-rouge">&lt;Suspense&gt;</code> to wrap that component.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">FetchDataComponentSkeleton</span> <span class="o">/&gt;</span><span class="p">}</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">FetchDataComponent</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span></code></pre></div></div> <h4 id="grouping-components-pattern">Grouping Components Pattern</h4> <p>You can use Grouping components pattern when you want multiple components to load in at the same time. Step:</p> <ul> <li>Wrap all these multiple components into one component call WrapComponent.</li> <li>These Grouping components inside the WrapComponent can use <code class="language-plaintext highlighter-rouge">Promise.all</code> to parallel fetch data.</li> <li>Using <code class="language-plaintext highlighter-rouge">&lt;Suspense&gt;</code> to wrap that WrapComponent.</li> </ul> <h3 id="what-is-partial-prerendering">What is Partial Prerendering</h3> <p>Application behaves today, where entire routes are either entirely static or dynamic.</p> <p>Partial Prerendering allows you to render a route with a static loading shell, while keeping some parts dynamic. In other words, you can isolate the dynamic parts of a route.</p> <p>When a user visits a route:</p> <ul> <li>A static route shell is served, ensuring a fast initial load.</li> <li>The shell leaves holes where dynamic content will load in asynchronous.</li> <li>The async holes are streamed in parallel, reducing the overall load time of the page.</li> </ul> <h3 id="can-suspense-used-on-server">Can Suspense used on Server?</h3> <h2 id="dynamic-routes">Dynamic Routes</h2> <p>Next.js allows you to create Dynamic Route Segments when you don’t know the exact segment name and want to create routes based on data. This could be product ID, blog post titles, product pages, etc. You can create dynamic route segments by wrapping a folder’s name in square brackets. For example, [id], [post] or [slug].</p> <p>For example, you need a invoice update function. Then you need to Create a Dynamic Route Segment with the invoice id.</p> <h3 id="create-dynamic-route-steps">Create Dynamic Route Steps:</h3> <ul> <li> <p>In your /invoices folder, create a new dynamic route called [id], then a new route called <code class="language-plaintext highlighter-rouge">edit</code> with a <code class="language-plaintext highlighter-rouge">page.tsx</code> file.</p> </li> <li> <p>The Update Button for each invoice will do this.</p> </li> </ul> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Link</span>
  <span class="na">href=</span><span class="s">{`/dashboard/invoices/${id}/edit`}</span>
  <span class="na">className=</span><span class="s">"rounded-md border p-2 hover:bg-gray-100"</span>
<span class="nt">&gt;</span>
</code></pre></div></div> <ul> <li>Inside the <code class="language-plaintext highlighter-rouge">[id]/edit/page.tsx</code>, it will Read the invoice <code class="language-plaintext highlighter-rouge">id</code> from page <code class="language-plaintext highlighter-rouge">params</code>.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">Page</span><span class="p">({</span> <span class="nx">params</span> <span class="p">}:</span> <span class="p">{</span> <span class="nl">params</span><span class="p">:</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p>Inside the <code class="language-plaintext highlighter-rouge">[id]/edit/page.tsx</code>, you will Fetch the specific invoice according to the <code class="language-plaintext highlighter-rouge">id</code> to fill the page.</p> </li> <li> <p>When user confirm update, You will update Database by using Server Action. At this moment, You can’t just pass <code class="language-plaintext highlighter-rouge">id</code> to server action! Instead, you can pass id to the Server Action using JS bind.</p> </li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">updateInvoiceWithId</span> <span class="o">=</span> <span class="nx">updateInvoice</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">invoice</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="k">return </span><span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">action</span><span class="o">=</span><span class="p">{</span><span class="nx">updateInvoiceWithId</span><span class="p">}</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span> <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">hidden</span><span class="dl">"</span> <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">id</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">invoice</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div> <h3 id="generatestaticparams">generateStaticParams</h3> <ul> <li>The <code class="language-plaintext highlighter-rouge">generateStaticParams</code> function is used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.</li> <li>When exporting a function called <code class="language-plaintext highlighter-rouge">generateStaticParams</code> from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by <code class="language-plaintext highlighter-rouge">generateStaticParams</code>.</li> <li> <code class="language-plaintext highlighter-rouge">generateStaticParams</code> replaces the <code class="language-plaintext highlighter-rouge">getStaticPaths</code> function in the Pages Router.</li> <li>The primary benefit of the <code class="language-plaintext highlighter-rouge">generateStaticParams</code> function is its smart retrieval of data. If content is fetched within the <code class="language-plaintext highlighter-rouge">generateStaticParams</code> function using a fetch request, the requests are automatically memoized. This means a <code class="language-plaintext highlighter-rouge">fetch</code> request with the same arguments across multiple <code class="language-plaintext highlighter-rouge">generateStaticParams</code>, Layouts, and Pages will only be made once, which decreases build times.</li> </ul> <h3 id="catch-all-segments">Catch-all Segments</h3> <p>Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets <code class="language-plaintext highlighter-rouge">[...folderName].</code></p> <p>For example, <code class="language-plaintext highlighter-rouge">app/shop/[...slug]/page.js</code> will match <code class="language-plaintext highlighter-rouge">/shop/clothes</code>, but also <code class="language-plaintext highlighter-rouge">/shop/clothes/tops</code>, <code class="language-plaintext highlighter-rouge">/shop/clothes/tops/t-shirts</code>, and so on.</p> <p>Catch-all Segments can be made optional by including the parameter in double square brackets: <code class="language-plaintext highlighter-rouge">[[...folderName]]</code>.</p> <h2 id="parallel-routes">Parallel Routes</h2> <p>Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.</p> <h3 id="slots">Slots</h3> <ul> <li>Parallel routes are created using named slots.</li> <li>Slots are defined with the <code class="language-plaintext highlighter-rouge">@folder</code> convention. Like <code class="language-plaintext highlighter-rouge">app/@slot/page.js</code>.</li> <li>Slots are passed as <code class="language-plaintext highlighter-rouge">props</code> to the shared parent layout. (layout usaully have current page as <code class="language-plaintext highlighter-rouge">children</code> prop, that means the <code class="language-plaintext highlighter-rouge">children</code> prop is an implicit slot that does not need to be mapped to a folder. <code class="language-plaintext highlighter-rouge">app/page.js</code> is equivalent to <code class="language-plaintext highlighter-rouge">app/@children/page.js</code>.)</li> <li>Slots are not route segments and do not affect the URL structure.</li> </ul> <h3 id="navigation-1">Navigation</h3> <p>When you use Parallel route, you will face some situation, like navigation:</p> <ul> <li>Soft Navigation: During client-side navigation, Next.js will perform a partial render, changing the subpage within the slot, while maintaining the other slot’s active subpages, even if they don’t match the current URL.</li> <li>Hard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don’t match the current URL. Instead, it will render a default.js file for the unmatched slots, or 404 if <code class="language-plaintext highlighter-rouge">default.js</code> doesn’t exist.</li> </ul> <h4 id="defaultjs">default.js</h4> <p>You can define a <code class="language-plaintext highlighter-rouge">default.js</code> file to render as a fallback for unmatched slots during the initial load or full-page reload.</p> <h3 id="use-parallel-route">Use Parallel route</h3> <ul> <li>Conditional Routes: You can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the <code class="language-plaintext highlighter-rouge">/admin</code> or <code class="language-plaintext highlighter-rouge">/user</code> roles.</li> <li>Use layout inside slot.</li> <li>Modals Parallel Routes can be used together with “Intercepting Routes” to create modals. This allows you to solve common challenges when building modals, such as: <ul> <li>Making the modal content shareable through a URL.</li> <li>Preserving context when the page is refreshed, instead of closing the modal.</li> <li>Closing the modal on backwards navigation rather than going to the previous route.</li> <li>Reopening the modal on forwards navigation.</li> </ul> </li> </ul> <h2 id="intercepting-routes">Intercepting Routes</h2> <p>Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.</p> <p>For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the <code class="language-plaintext highlighter-rouge">/photo/123</code> route, masks the URL, and overlays it over <code class="language-plaintext highlighter-rouge">/feed</code>.</p> <h3 id="convention">Convention</h3> <p>Intercepting routes can be defined with the <code class="language-plaintext highlighter-rouge">(..)</code> convention, which is similar to relative path convention <code class="language-plaintext highlighter-rouge">../</code> but for segments.</p> <p>You can use:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">(.)</code> to match segments on the same level</li> <li> <code class="language-plaintext highlighter-rouge">(..)</code> to match segments one level above</li> <li> <code class="language-plaintext highlighter-rouge">(..)(..)</code> to match segments two levels above</li> <li> <code class="language-plaintext highlighter-rouge">(...)</code> to match segments from the root app directory</li> </ul> <p>For example, you can intercept the photo segment from within the feed segment by creating a <code class="language-plaintext highlighter-rouge">(..)photo</code> directory.</p> <h3 id="modals">Modals</h3> <p>Intercepting Routes can be used together with Parallel Routes to create modals.</p> <h2 id="route-handler">Route Handler</h2> <h3 id="what-is-route-handler">What is Route Handler</h3> <p>Route Handlers allow you to create <strong>custom request handlers</strong> for a given route using the Web Request and Response APIs. Route Handlers need to be defined in a <strong><code class="language-plaintext highlighter-rouge">route.ts</code></strong> file inside the app directory.</p> <p>Basic Example:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/api/route.ts</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">GET</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://data.mongodb-api.com/...</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span><span class="p">,</span>
      <span class="dl">'</span><span class="s1">API-Key</span><span class="dl">'</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DATA_API_KEY</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">})</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">Response</span><span class="p">.</span><span class="nf">json</span><span class="p">({</span> <span class="nx">data</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now, any Get Request at route <code class="language-plaintext highlighter-rouge">api/</code> will be handled by the export function <code class="language-plaintext highlighter-rouge">GET()</code>.</p> <h3 id="route-handler-features">Route Handler Features</h3> <ul> <li>Route Handlers can be nested inside the app directory, similar to page.js and layout.js.</li> <li>Each route.js or page.js file takes over all HTTP verbs for that route. So they can’t be at same route segment.</li> <li>Route Handlers are cached by default when using the <code class="language-plaintext highlighter-rouge">GET</code> method with the Response object.</li> <li>In the old version, Next.js Page Route, it use “API Routes” to do the same job: providing a solution to build a public API.</li> </ul> <h3 id="what-you-can-do-with-route-handler">What you can do with Route Handler</h3> <ul> <li>You setup Revalidate Cached Data for a Route API.</li> <li>Route Handlers can be used with dynamic functions from Next.js, like cookies and headers.</li> <li>Redirects</li> <li>Support Dynamic Route Segments</li> <li>The request object passed to the Route Handler is a NextRequest instance, which has some additional convenience methods.</li> <li>Use Streaming with Large Language Models (LLMs), such as OpenAI, for AI-generated content.</li> <li>You can use Request Body FormData.</li> </ul> <h3 id="when-to-use-route-handler">When to use Route Handler??</h3> <h2 id="internationalization">Internationalization</h2> <p>Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes.</p> <h3 id="how">How</h3> <p>Using some 3th libraries, you can look at an incoming Request to determine which locale to select. With this information, redirect the user based on the locale inside <strong>Middleware</strong>.</p> <p>Even the root layout can also be nested in the new folder (e.g. app/[lang]/layout.js).</p> <p>You can use <code class="language-plaintext highlighter-rouge">generateStaticParams</code> with any page or layout to generate static routes for a given set of locales.</p> <h2 id="faq">FAQ</h2> <h3 id="how-to-refresh-a-server-component">How to refresh a server component?</h3> <ul> <li>In the Client component, use <code class="language-plaintext highlighter-rouge">const router = useRouter();</code> and <code class="language-plaintext highlighter-rouge">router.refresh();</code> </li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Apr 14, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/next-js"> <i class="fas fa-tag fa-sm"></i> Next.js</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/next-js"> <div class="tag"> Next.js </div> </a> <a href="/blog/tag/router"> <div class="tag"> Router </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#what-is-routing"> # What is Routing </a> </div> <div class="toc-item"> <a href="#app-route-vs-page-route"> # App Route vs Page Route </a> </div> <div class="toc-item"> <a href="#app-route-basic"> # App Route Basic </a> </div> <div class="toc-item"> <a href="#navigation"> # Navigation </a> </div> <div class="toc-item"> <a href="#streaming"> # Streaming </a> </div> <div class="toc-item"> <a href="#dynamic-routes"> # Dynamic Routes </a> </div> <div class="toc-item"> <a href="#parallel-routes"> # Parallel Routes </a> </div> <div class="toc-item"> <a href="#intercepting-routes"> # Intercepting Routes </a> </div> <div class="toc-item"> <a href="#route-handler"> # Route Handler </a> </div> <div class="toc-item"> <a href="#internationalization"> # Internationalization </a> </div> <div class="toc-item"> <a href="#faq"> # FAQ </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>