<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Python Asyncio | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/py-asyncio/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Python Asyncio</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <h2 id="what-is-asyncio">What is asyncio</h2> <p>Asyncio is a built-in library of Python to write concurrent code using <code class="language-plaintext highlighter-rouge">async/await</code> syntax. This library provides high-performance network and web servers, database connection libraries, distributed task queues, etc., for asynchronous programming.</p> <ul> <li>asyncio is the concurrency module introduced in Python 3.4.</li> <li>It is designed to use coroutines and futures to simplify asynchronous code and make it almost as readable as synchronous code as there are no callbacks.</li> <li>To understand sayncio, the key point is understand event loop, although somebody keep saying coroutine is the core feature.</li> <li>The asyncio package is a library to write concurrent code. However, async IO is not threading, nor is it multiprocessing. It is not built on top of either of these.</li> <li>async IO is a single-threaded, single-process design: it uses cooperative multitasking.</li> <li>async IO gives a feeling of concurrency despite using a single thread in a single process.</li> <li>By default asyncio runs in production mode. In order to ease the development asyncio has a debug mode.</li> </ul> <h3 id="event-loops-coroutines-and-futures-concepts">event loops, coroutines and futures concepts</h3> <ul> <li>An <strong>event loop</strong> manages and distributes the execution of different tasks. It registers them and handles distributing the flow of control between them.</li> <li> <strong>Coroutines</strong> are special functions that work similarly to Python generators, on await they release the flow of control back to the event loop. A coroutine needs to be scheduled to run on the event loop, once scheduled coroutines are wrapped in Tasks which is a type of Future.</li> <li> <strong>Futures</strong> represent the result of a task that may or may not have been executed. This result may be an exception.</li> </ul> <h2 id="coroutines">Coroutines</h2> <h3 id="what-is-coroutines">What is Coroutines</h3> <ul> <li>Detail on PEP 492.</li> <li>Coroutines declared with the async/await syntax is the preferred way of writing asyncio applications.</li> <li>Example:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">world</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>Python coroutines are awaitables and therefore can be awaited from other coroutines.</li> <li>Simply calling a coroutine will not schedule it to be executed.</li> <li>To actually run a coroutine in the event loop, asyncio provides the following mechanisms: <ul> <li>asyncio.run()</li> <li>asyncio.create_task()</li> <li>asyncio.TaskGroup()</li> </ul> </li> <li>The term “coroutine” can be used for two closely related concepts: <ul> <li>a coroutine function: an async def function;</li> <li>a coroutine object: an object returned by calling a coroutine function.</li> </ul> </li> <li>A coroutine is a specialized version of a Python generator function.</li> <li>The keyword async def introduces a native coroutine.</li> <li>The keyword await passes function control back to the event loop.</li> </ul> <h4 id="chaining-coroutines">Chaining Coroutines</h4> <p>A key feature of coroutines is that they can be chained together. (Remember, a coroutine object is awaitable, so another coroutine can await it.) This allows you to break programs into smaller, manageable, recyclable coroutines</p> <h3 id="coroutines-is-generators">Coroutines is generators</h3> <ul> <li>Coroutines are repurposed generators that take advantage of the peculiarities of generator methods.</li> <li>Old generator-based coroutines use yield from to wait for a coroutine result. Modern Python syntax in native coroutines simply replaces yield from with await as the means of waiting on a coroutine result.</li> <li>The use of await is a signal that marks a break point. It lets a coroutine temporarily suspend execution and permits the program to come back to it later.</li> </ul> <h3 id="awaitable-object">Awaitable Object</h3> <ul> <li>An awaitable object generally implements an <code class="language-plaintext highlighter-rouge">__await__()</code> method.</li> <li> <p>Note: The generator iterator objects returned from generators decorated with types.coroutine() are also awaitable, but they do not implement <code class="language-plaintext highlighter-rouge">__await__()</code>.</p> </li> <li>We say that an object is an awaitable object if it can be used in an await expression.</li> <li>Many asyncio APIs are designed to accept awaitables.</li> <li>There are three main types of awaitable objects: coroutines, Tasks, and Futures.</li> </ul> <h3 id="coroutine-obejct">Coroutine Obejct</h3> <p>Coroutine objects returned from async def functions are awaitable.</p> <ul> <li>A coroutine’s execution can be controlled by calling <code class="language-plaintext highlighter-rouge">__await__()</code> and iterating over the result.</li> <li>Coroutines have the methods which are analogous to those of generators. Like coroutine.send(value), coroutine.throw(value), coroutine.close().</li> <li>However, unlike generators, coroutines do not directly support iteration.</li> </ul> <h3 id="asynchronous-iterators-and-async-for">Asynchronous Iterators and “async for”</h3> <p>Along with plain <code class="language-plaintext highlighter-rouge">async/await</code>, Python also enables async for to iterate over an asynchronous iterator.</p> <h4 id="what-is-asynchronous-iterator">What is asynchronous iterator</h4> <ul> <li> <p>An asynchronous iterable is able to call asynchronous code in its iter implementation, and asynchronous iterator can call asynchronous code in its next method.</p> </li> <li>To support asynchronous iteration: <ul> <li>An object must implement an <code class="language-plaintext highlighter-rouge">__aiter__</code> method returning an asynchronous iterator object.</li> <li>An asynchronous iterator object must implement an <code class="language-plaintext highlighter-rouge">__anext__</code> method returning an awaitable.</li> <li>To stop iteration <code class="language-plaintext highlighter-rouge">__anext__</code> must raise a StopAsyncIteration exception.</li> </ul> </li> <li>An example of asynchronous iterable:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AsyncIterable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="nf">fetch_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">StopAsyncIteration</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="bp">...</span>
</code></pre></div></div> <ul> <li>A new statement for iterating through asynchronous iterators is supported:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">for</span> <span class="n">TARGET</span> <span class="ow">in</span> <span class="n">ITER</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</code></pre></div></div> <p>which is semantically equivalent to:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">ITER</span><span class="p">)</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">).</span><span class="nf">__aiter__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">TARGET</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">).</span><span class="nf">__anext__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">StopAsyncIteration</span><span class="p">:</span>
        <span class="n">running</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</code></pre></div></div> <ul> <li>The purpose of an asynchronous iterator is for it to be able to call asynchronous code at each stage when it is iterated over.</li> </ul> <h3 id="asynchronous-context-managers-and-async-with-">Asynchronous Context Managers And “async with ”</h3> <ul> <li>An asynchronous context manager is a context manager that is able to suspend execution in its <code class="language-plaintext highlighter-rouge">__aenter__</code> and <code class="language-plaintext highlighter-rouge">__aexit__</code> methods.</li> <li>Asynchronous context managers can be used in an <code class="language-plaintext highlighter-rouge">async with</code> statement.</li> </ul> <h2 id="task">Task</h2> <ul> <li>Task is a concept which interact with event loop.</li> <li>Tasks are one of the primary ways to interact with the event loop.</li> <li>Tasks wrap coroutines and track when they are complete.</li> <li>Tasks are used to run coroutines in event loops. If a coroutine awaits on a Future, the Task suspends the execution of the coroutine and waits for the completion of the Future. When the Future is done, the execution of the wrapped coroutine resumes.</li> <li>Tasks are used to schedule coroutines concurrently.</li> <li>When a coroutine is wrapped into a Task with functions like asyncio.create_task() the coroutine is automatically scheduled to run soon.</li> </ul> <h3 id="create-task">Create task</h3> <p>asyncio.create_task(coro)</p> <ul> <li>Wrap the coro coroutine into a Task and schedule its execution. Return the Task object.</li> <li>The task is executed in the loop returned by get_running_loop()</li> <li>Save a reference to the result of this function, to avoid a task disappearing mid-execution.</li> <li>asyncio.TaskGroup.create_task() is a newer alternative that allows for convenient waiting for a group of related tasks.</li> </ul> <h4 id="still-have-no-idea-why-need-task-to-wrap-a-coroutine">Still have no idea why need task to wrap a coroutine?</h4> <p>OK, let’s clear it.</p> <ul> <li>Firstly, coroutine just work within a event loop. You can just simply use asyncio.run(coro) to creates a new event loop to run coro and closes it at the end.</li> <li>When you are using asyncio.gather() for concurrency, it actually use task.</li> <li>Using task provide more control, more features. For example, according code below:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello</span><span class="sh">"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">not_task</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">await</span> <span class="nf">say_hello</span><span class="p">()</span>
    <span class="k">await</span> <span class="nf">say_hello</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">is_task</span><span class="p">():</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">say_hello</span><span class="p">())</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">say_hello</span><span class="p">())</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">t1</span>
    <span class="k">await</span> <span class="n">t2</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>understand HOW not_task() and is_task() work when wrap them in run(). Running not_task() coroutine object, it take 4 seconds; Running is_task(), it can run concurrently, it take 2 seconds.</li> </ul> <h3 id="task-groups">Task Groups</h3> <ul> <li>New at version 3.11</li> <li>Task groups combine a task creation API with a convenient and reliable way to wait for all tasks in the group to finish.</li> </ul> <h2 id="futures">Futures</h2> <ul> <li>A Future is a special low-level awaitable object that represents an eventual result of an asynchronous operation.</li> <li>Future objects are used to bridge low-level callback-based code with high-level async/await code.</li> <li>When a Future object is awaited it means that the coroutine will wait until the Future is resolved in some other place.</li> <li>Future objects in asyncio are needed to allow callback-based code to be used with async/await.</li> <li>Normally there is no need to create Future objects at the application level code.</li> <li>Future objects, sometimes exposed by libraries and some asyncio APIs, can be awaited.</li> </ul> <h2 id="event-loop">Event loop</h2> <ul> <li>The event loop is the core of every asyncio application that takes care of all the running tasks.</li> <li>The event loop supports multitasking. When a function is suspended, control returns to the loop, which then finds another function to start or resume.</li> <li>Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.</li> <li>Event loops use cooperative scheduling: an event loop runs one Task at a time. While a Task awaits for the completion of a Future, the event loop runs other Tasks, callbacks, or performs IO operations.</li> <li>Event loop interface provide low-level APIs. Application developers should rarely need to reference the loop object or call its methods.</li> <li>By default, an async IO event loop runs in a single thread and on a single CPU core.</li> <li>Event loops are pluggable. That is, you could, if you really wanted, write your own event loop implementation and have it run tasks just the same.</li> </ul> <figure> <picture> <img src="/assets/img/py-eventloop.jpg" class="img-fluid rounded z-depth-1" width="60%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="how-event-loop-work">How event loop work</h3> <ul> <li>An event loop runs in a thread (typically the main thread) and executes all callbacks and Tasks in its thread.</li> <li>While a Task is running in the event loop, no other Tasks can run in the same thread.</li> <li>When a Task executes an await expression, the running Task gets suspended, and the event loop executes the next Task.</li> <li>To schedule a callback from another OS thread, the loop.call_soon_threadsafe() method should be used.</li> </ul> <h3 id="high-level-asyncio-functions">high-level asyncio functions</h3> <h4 id="asyncioruncoro">asyncio.run(coro)</h4> <ul> <li>asyncio.run() introduced in Python 3.7, is responsible for getting the event loop, running tasks until they are marked as complete, and then closing the event loop.</li> <li>It runs the passed coro, taking care of managing the asyncio event loop and closing the threadpool.</li> <li>This function cannot be called when another asyncio event loop is running in the same thread.</li> <li>It should be used as a main entry point for asyncio programs, and should ideally only be called once.</li> <li>There’s a more long-winded way of managing the asyncio event loop, with get_event_loop().</li> </ul> <h3 id="low-level-functions">low-level functions</h3> <p>Application developers should typically use the high-level asyncio functions, such as asyncio.run(), and should rarely need to reference the loop object or call its methods.</p> <h4 id="asyncioget_running_loop">asyncio.get_running_loop()</h4> <ul> <li>Return the running event loop in the current OS thread.</li> <li>Raise a RuntimeError if there is no running event loop.</li> <li>This function can only be called from a coroutine or a callback.</li> </ul> <h4 id="asyncioget_event_loop">asyncio.get_event_loop()</h4> <ul> <li>When called from a coroutine or a callback, this function will always return the running event loop.</li> <li>If there is no running event loop set, the function will return the result of the get_event_loop_policy().get_event_loop() call.</li> <li>Consider using the higher-level asyncio.run() function, instead of using these lower level functions to manually create and close an event loop.</li> </ul> <h4 id="asyncioset_event_looploop">asyncio.set_event_loop(loop)</h4> <p>Set loop as the current event loop for the current OS thread.</p> <h4 id="asyncionew_event_loop">asyncio.new_event_loop()</h4> <p>Create and return a new event loop object.</p> <h3 id="event-loop-methods">Event Loop Methods</h3> <h4 id="running-and-stopping-the-loop">Running and stopping the loop</h4> <ul> <li> <p><code class="language-plaintext highlighter-rouge">loop.run_until_complete(future)</code>: Run until the future (an instance of Future) has completed.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">loop.run_forever()</code>: Run the event loop until stop() is called.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">loop.close()</code>: Close the event loop.</p> </li> </ul> <h4 id="scheduling-callbacks">Scheduling callbacks</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">loop.call_soon(callback, *args, context=None)</code>: Schedule the callback callback to be called with args arguments at the next iteration of the event loop. Callbacks are called in the order in which they are registered. Each callback will be called exactly once.</li> <li> <code class="language-plaintext highlighter-rouge">loop.call_soon_threadsafe(callback, *args, context=None)</code>: When scheduling callbacks from another thread, this function must be used.</li> <li> <code class="language-plaintext highlighter-rouge">loop.call_later(delay, callback, *args, context=None)</code>: Schedule callback to be called after the given delay number of seconds.</li> <li> <code class="language-plaintext highlighter-rouge">loop.call_at(when, callback, *args, context=None)</code>: Schedule callback to be called at the given absolute timestamp when (an int or a float), using the same time reference as loop.time().</li> <li> <code class="language-plaintext highlighter-rouge">loop.time()</code>: Return the current time, as a float value, according to the event loop’s internal monotonic clock.</li> </ul> <h4 id="creating-futures-and-tasks">Creating Futures and Tasks</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">loop.create_future()</code> Create an asyncio.Future object attached to the event loop.</li> </ul> <p>This is the preferred way to create Futures in asyncio. This lets third-party event loops provide alternative implementations of the Future object</p> <ul> <li> <code class="language-plaintext highlighter-rouge">loop.create_task(coro, *, name=None, context=None)</code> Schedule the execution of coroutine coro. Return a Task object.</li> </ul> <h4 id="opening-network-connections">Opening network connections</h4> <ul> <li>coroutine loop.create_connection() Open a streaming transport connection to a given address specified by host and port.</li> <li>coroutine loop.create_datagram_endpoint() Create a datagram connection.</li> <li>coroutine loop.create_unix_connection()</li> </ul> <h4 id="creating-network-servers">Creating network servers</h4> <ul> <li>coroutine loop.create_server() Create a TCP server (socket type SOCK_STREAM) listening on port of the host address.</li> </ul> <h2 id="asynchronous-context-manager">asynchronous context manager</h2> <p>An asynchronous context manager is a context manager that is able to suspend execution in its <strong>aenter</strong> and <strong>aexit</strong> methods.</p> <h3 id="runner-context-manager">Runner context manager</h3> <p><code class="language-plaintext highlighter-rouge">class asyncio.Runner(*, debug=None, loop_factory=None)</code></p> <ul> <li>A context manager that simplifies multiple async function calls in the same context.</li> <li>Sometimes several top-level async functions should be called in the same event loop and contextvars.Context.</li> <li>Basically, asyncio.run() example can be rewritten with the runner usage:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">)</span>

<span class="k">with</span> <span class="n">asyncio</span><span class="p">.</span><span class="nc">Runner</span><span class="p">()</span> <span class="k">as</span> <span class="n">runner</span><span class="p">:</span>
    <span class="n">runner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">())</span>
</code></pre></div></div> <h3 id="coroutine-asynciotimeoutdelay">coroutine asyncio.timeout(delay)</h3> <p>An asynchronous context manager that can be used to limit the amount of time spent waiting on something.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">await</span> <span class="nf">long_running_task</span><span class="p">()</span>
    <span class="k">except</span> <span class="nb">TimeoutError</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">The long operation timed out, but we</span><span class="sh">'</span><span class="s">ve handled it.</span><span class="sh">"</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">This statement will run regardless.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h2 id="usage">Usage</h2> <h3 id="sleeping">Sleeping</h3> <p><code class="language-plaintext highlighter-rouge">coroutine asyncio.sleep(delay)</code> Example, wait 1 second: <code class="language-plaintext highlighter-rouge">await asyncio.sleep(1)</code></p> <h3 id="running-tasks-concurrently">Running Tasks Concurrently</h3> <p><code class="language-plaintext highlighter-rouge">awaitable asyncio.gather(*aws)</code></p> <ul> <li>Run awaitable objects in the aws sequence concurrently.</li> <li>If any awaitable in aws is a coroutine, it is automatically scheduled as a Task.</li> </ul> <h3 id="task-groups-1">Task groups</h3> <ul> <li>New in version 3.11</li> <li>Task groups combine a task creation API with a convenient and reliable way to wait for all tasks in the group to finish.</li> <li> <code class="language-plaintext highlighter-rouge">class asyncio.TaskGroup</code> An asynchronous context manager holding a group of tasks. Tasks can be added to the group using TaskGroup.<code class="language-plaintext highlighter-rouge">create_task()</code>. All tasks are awaited when the context manager exits.</li> </ul> <p>Example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="p">.</span><span class="nc">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="n">task1</span> <span class="o">=</span> <span class="n">tg</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">some_coro</span><span class="p">(...))</span>
        <span class="n">task2</span> <span class="o">=</span> <span class="n">tg</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">another_coro</span><span class="p">(...))</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Both tasks have completed now.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>The async with statement will wait for all tasks in the group to finish.</p> <p>Other topics:</p> <ul> <li>Shielding From Cancellation</li> <li>Timeouts</li> <li>Waiting Primitives</li> <li>Running in Threads</li> <li>Scheduling From Other Threads</li> </ul> <h2 id="faq">FAQ</h2> <ul> <li>Asynchronous programming and Generator</li> <li>Are all coroutines which are in the same asyncio.run() are in a same thread? One event loop locate in one thread?</li> <li>The current thread which execute asyncio.run() is other than the event loop thread?</li> </ul> <h4 id="what-is-concurrent-computing">What is Concurrent computing</h4> <p>Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially—with one completing before the next starts.</p> <p>Concurrency is not Parallelism</p> <ul> <li>Concurrency and parallelism, a related but quite distinct concept.</li> <li>In programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations.</li> <li>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</li> <li>Concurrency is talk about structure, while parallelism is about execution.</li> <li>Concurrency maybe use parallelism, but parallelism is not it’s goal.</li> <li>An analogue: OS need to handle many stuff, keyboard, mouse input,screen output, response many socket. But it don’t have to be parallelism. it use concurrent model.</li> <li>Parallelism, for example, break a big job into many small jobs and execute them in parallel way.</li> </ul> <h4 id="asynciocoroutine">@asyncio.coroutine</h4> <p>async/await is new syntax. @asyncio.coroutine return a generator-based coroutine which outdated.</p> <p>Example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">py34_coro</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Generator-based coroutine, older syntax</span><span class="sh">"""</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="nf">stuff</span><span class="p">()</span>
<span class="n">same</span> <span class="k">with</span><span class="p">:</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">py35_coro</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Native coroutine, modern syntax</span><span class="sh">"""</span>
    <span class="k">await</span> <span class="nf">stuff</span><span class="p">()</span>
</code></pre></div></div> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Dec 27, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/python"> <i class="fas fa-tag fa-sm"></i> Python</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/python"> <div class="tag"> Python </div> </a> <a href="/blog/tag/asynchronous"> <div class="tag"> Asynchronous </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#what-is-asyncio"> # What is asyncio </a> </div> <div class="toc-item"> <a href="#coroutines"> # Coroutines </a> </div> <div class="toc-item"> <a href="#task"> # Task </a> </div> <div class="toc-item"> <a href="#futures"> # Futures </a> </div> <div class="toc-item"> <a href="#event-loop"> # Event loop </a> </div> <div class="toc-item"> <a href="#asynchronous-context-manager"> # asynchronous context manager </a> </div> <div class="toc-item"> <a href="#usage"> # Usage </a> </div> <div class="toc-item"> <a href="#faq"> # FAQ </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>