<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Next.js Caching introduction | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/nextjs-cache/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Next.js Caching introduction</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <h2 id="caching-overview">Caching Overview</h2> <p>Next.js is a framework, it provide the whole cache solusion. It use React Cache machinisum, also it provide it own machinisum. Basically it can be divided into 4 categories: There are 4 different caching mechanisms:</p> <ul> <li>Request Memoization: based on React extand <code class="language-plaintext highlighter-rouge">fetch</code> function</li> <li>Data Cache: based on Next.js extand <code class="language-plaintext highlighter-rouge">fetch</code> function</li> <li>Full Route Cache: Next.js prepare this at <strong>Build-Time</strong>, at Sever-side</li> <li>Client-side Router Cache: Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to at Client side. Simply say using <code class="language-plaintext highlighter-rouge">&lt;link/&gt;</code> </li> </ul> <h2 id="some-concepts">Some Concepts</h2> <ul> <li> <code class="language-plaintext highlighter-rouge">fetch</code> API</li> <li>React cache</li> <li>Next.js <code class="language-plaintext highlighter-rouge">unstable_cache</code> </li> <li>Server Rendering Strategies <ul> <li> <strong>Static Rendering (Default)</strong>: With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN).</li> <li> <strong>Dynamic Rendering</strong>: With Dynamic Rendering, routes are rendered for each user at request time. During rendering, if a <em>Dynamic API</em> or <em>uncached data</em> request is discovered, Next.js will <em>switch</em> to dynamically rendering the whole route.</li> <li> <strong>Streaming</strong>: Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.</li> <li>As a developer, you do not need to choose between static and dynamic rendering as Next.js will automatically choose the best rendering strategy for each route based on the features and APIs used. Instead, you choose when to <strong>cache</strong> or <strong>revalidate</strong> specific data, and you may choose to stream parts of your UI.</li> <li>Dynamic APIs: like <code class="language-plaintext highlighter-rouge">cookies</code>, <code class="language-plaintext highlighter-rouge">headers</code>, or reading the incoming <code class="language-plaintext highlighter-rouge">searchParams</code> from the page props etc. which will automatically make the page render dynamically.</li> </ul> </li> <li>RSC Payload and data are cached separately.</li> </ul> <h2 id="nextjs-caching-foundation">Next.js Caching Foundation</h2> <p>If you use <code class="language-plaintext highlighter-rouge">next dev</code> to run the application. it wonâ€™t cache the response. But when you run a production build by using <code class="language-plaintext highlighter-rouge">next build</code>, even for the server components, they will be revaluated during the build, and they will be set to be prerendered by default. (The same thing is applied for route handler.)</p> <p>It can switch to Dynamic Rendering if a <code class="language-plaintext highlighter-rouge">Dynamic API</code> or <code class="language-plaintext highlighter-rouge">uncached data</code> request is discovered.</p> <p>APIs and data caching affect whether a route is statically or dynamically rendered:</p> <figure> <picture> <img src="/assets/img/sever-rendering-switch.png" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="example-of-using-caching-when-fetching">Example of Using Caching when fetching</h2> <h3 id="fetching-data-on-the-server-with-the-fetch-api">Fetching data on the server with the fetch API</h3> <p>If you are using <code class="language-plaintext highlighter-rouge">fetch</code>, <code class="language-plaintext highlighter-rouge">requests</code> are automatically memoized. This means you can safely call the same URL with the same options, and only one <code class="language-plaintext highlighter-rouge">request</code> will be made. The response from fetch will be automatically cached: <code class="language-plaintext highlighter-rouge">let data = await fetch('https://api.example.app/blog')</code> If you do not want to cache the response from fetch, you can do the following: <code class="language-plaintext highlighter-rouge">let data = await fetch('https://api.example.app/blog', { cache: 'no-store' })</code></p> <h3 id="caching-data-with-an-orm-or-database">Caching data with an ORM or Database</h3> <p>You can use the <code class="language-plaintext highlighter-rouge">unstable_cache</code> API to cache the response to allow pages to be prerendered when running <code class="language-plaintext highlighter-rouge">next build</code>.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">unstable_cache</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">next/cache</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">db</span><span class="p">,</span> <span class="nx">posts</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@/lib/db</span><span class="dl">'</span>
 
<span class="kd">const</span> <span class="nx">getPosts</span> <span class="o">=</span> <span class="nf">unstable_cache</span><span class="p">(</span>
  <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nx">db</span><span class="p">.</span><span class="nf">select</span><span class="p">().</span><span class="k">from</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="p">[</span><span class="dl">'</span><span class="s1">posts</span><span class="dl">'</span><span class="p">],</span>
  <span class="p">{</span> <span class="na">revalidate</span><span class="p">:</span> <span class="mi">3600</span><span class="p">,</span> <span class="na">tags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">posts</span><span class="dl">'</span><span class="p">]</span> <span class="p">}</span>
<span class="p">)</span>
 
<span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">allPosts</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">getPosts</span><span class="p">()</span>
 
  <span class="k">return </span><span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">allPosts</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>This example caches the result of the database query for 1 hour (3600 seconds). It also adds the cache tag posts which can then be invalidated with Incremental Static Regeneration.</p> <h2 id="in-depth-look">In-depth Look</h2> <p>There are 4 different caching mechanisms:</p> <ul> <li>Request Memoization</li> <li>Data Cache</li> <li>Full Route Cache</li> <li>Client-side Router Cache</li> </ul> <p>And they will interact with each other.</p> <p>Hereâ€™s a high-level overview:</p> <figure> <picture> <img src="/assets/img/caching-overview.png" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <blockquote> <p>By default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out.</p> </blockquote> <h3 id="request-memoization">Request Memoization</h3> <p>This is a React feature, not a Next.js feature. React extends the <code class="language-plaintext highlighter-rouge">fetch</code> API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.</p> <p>The memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.</p> <h3 id="data-cache">Data Cache</h3> <p>Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native <code class="language-plaintext highlighter-rouge">fetch</code> API to allow each request on the <strong>server</strong> to set its own persistent caching semantics.</p> <blockquote> <p>Good to know: In the browser, the <code class="language-plaintext highlighter-rouge">cache</code> option of <code class="language-plaintext highlighter-rouge">fetch</code> indicates how a request will interact with the browserâ€™s HTTP cache, in Next.js, the <code class="language-plaintext highlighter-rouge">cache</code> option indicates how a server-side request will interact with the serverâ€™s Data Cache.</p> </blockquote> <p>The Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.</p> <ul> <li>revalidate: <ul> <li>Time-based Revalidation: <code class="language-plaintext highlighter-rouge">fetch('https://api.example.app/blog', { next: { revalidate: 3600 } })</code> </li> <li>On-demand Revalidation: Data can be revalidated on-demand by path (<code class="language-plaintext highlighter-rouge">revalidatePath</code>) or by cache tag (<code class="language-plaintext highlighter-rouge">revalidateTag</code>).</li> </ul> </li> <li>opt-out: using <code class="language-plaintext highlighter-rouge">let data = await fetch('https://api.example.app/blog', { cache: 'no-store' })</code>.</li> </ul> <h4 id="differences-between-the-data-cache-and-request-memoization">Differences between the Data Cache and Request Memoization</h4> <p>While both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.</p> <h3 id="full-route-cache">Full Route Cache</h3> <p>Next.js automatically renders and caches routes at <strong>build time</strong>. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.</p> <h4 id="how-the-full-route-cache-works">How the Full Route Cache works</h4> <p>To understand how the Full Route Cache works, itâ€™s helpful to look at how React handles rendering, and how Next.js caches the result.</p> <ol> <li>React Rendering on the Server: The rendering work is split into chunks: by individual routes segments and Suspense boundaries.</li> <li>Next.js Caching on the Server (Full Route Cache): The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.</li> <li>React Hydration and Reconciliation on the Client: At request time, on the client: <ul> <li>The HTML is used to <strong>immediately show</strong> a fast non-interactive initial preview of the Client and Server Components.</li> <li>The RSC Payload is used to <strong>reconcile</strong> the Client and rendered Server Component trees, and update the DOM.</li> <li>The JavaScript instructions are used to <strong>hydrate</strong> Client Components and make the application interactive.</li> </ul> </li> <li>Next.js Caching on the Client (Router Cache): This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.</li> <li>Subsequent Navigations: On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.</li> </ol> <h4 id="static-and-dynamic-rendering">Static and Dynamic Rendering</h4> <p>This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:</p> <figure> <picture> <img src="/assets/img/static-and-dynamic-routes.avif" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="client-side-router-cache">Client-side Router Cache</h3> <p>Next.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.</p> <p>When a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of React state and browser state.</p> <h4 id="duration-and-invalidation">Duration and Invalidation</h4> <p>The cache is stored in the browserâ€™s temporary memory. While a page refresh will clear all cached segments.</p> <p>There are two ways you can invalidate the Router Cache:</p> <ul> <li>In a Server Action: <ul> <li>Revalidating data on-demand by path with (<code class="language-plaintext highlighter-rouge">revalidatePath</code>) or by cache tag with (<code class="language-plaintext highlighter-rouge">revalidateTag</code>)</li> <li>Using <code class="language-plaintext highlighter-rouge">cookies.set</code> or <code class="language-plaintext highlighter-rouge">cookies.delete</code> invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication).</li> </ul> </li> <li>Calling <code class="language-plaintext highlighter-rouge">router.refresh</code> will invalidate the Router Cache and make a new request to the server for the current route.</li> </ul> <h2 id="nextjs-apis-affect-caching">Next.js APIs affect caching</h2> <h3 id="link"><code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code></h3> <p>By default, the <code class="language-plaintext highlighter-rouge">&lt;Link&gt;</code> component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.</p> <h3 id="routerprefetch"><code class="language-plaintext highlighter-rouge">router.prefetch</code></h3> <p>The prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.</p> <h3 id="routerrefresh"><code class="language-plaintext highlighter-rouge">router.refresh</code></h3> <p>The refresh option of the useRouter hook can be used to manually refresh a route.</p> <h3 id="fetch"><code class="language-plaintext highlighter-rouge">fetch</code></h3> <p>Data returned from fetch is automatically cached in the Data Cache.</p> <h3 id="fetch-optionscache"><code class="language-plaintext highlighter-rouge">fetch options.cache</code></h3> <p>You can opt individual fetch into caching by setting the cache option to force-cache</p> <h3 id="fetch-optionsnextrevalidate"><code class="language-plaintext highlighter-rouge">fetch options.next.revalidate</code></h3> <p>You can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.</p> <h3 id="fetch-optionsnexttags-and-revalidatetag"><code class="language-plaintext highlighter-rouge">fetch options.next.tags and revalidateTag</code></h3> <p>Next.js has a cache tagging system for fine-grained data caching and revalidation.</p> <h3 id="revalidatepath"><code class="language-plaintext highlighter-rouge">revalidatePath</code></h3> <p>revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.</p> <h3 id="dynamic-apis">Dynamic APIs</h3> <p>Dynamic APIs like <code class="language-plaintext highlighter-rouge">cookies</code> and <code class="language-plaintext highlighter-rouge">headers</code>, and the <code class="language-plaintext highlighter-rouge">searchParams</code> prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.</p> <h3 id="segment-config-options">Segment Config Options</h3> <p>The Route Segment Config options can be used to override the route segment defaults or when youâ€™re not able to use the fetch API (e.g. database client or 3rd party libraries).</p> <h3 id="generatestaticparams"><code class="language-plaintext highlighter-rouge">generateStaticParams</code></h3> <p>For dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that werenâ€™t known at build time the first time theyâ€™re visited.</p> <h3 id="react-cache-function">React cache function</h3> <p>The React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.</p> <h2 id="references">References</h2> <ul> <li><a href="https://nextjs.org/docs/app/building-your-application/caching" rel="external nofollow noopener" target="_blank">next.js doc for caching</a></li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Oct 22, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/next-js"> <i class="fas fa-tag fa-sm"></i>Â Next.js</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/next-js"> <div class="tag"> Next.js </div> </a> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/router"> <div class="tag"> Router </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#caching-overview"> #Â Caching Overview </a> </div> <div class="toc-item"> <a href="#some-concepts"> #Â Some Concepts </a> </div> <div class="toc-item"> <a href="#next-js-caching-foundation"> #Â Next.js Caching Foundation </a> </div> <div class="toc-item"> <a href="#example-of-using-caching-when-fetching"> #Â Example of Using Caching when fetching </a> </div> <div class="toc-item"> <a href="#in-depth-look"> #Â In-depth Look </a> </div> <div class="toc-item"> <a href="#next-js-apis-affect-caching"> #Â Next.js APIs affect caching </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> Â© Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>