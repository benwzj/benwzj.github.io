<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Rendering Process in React | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/react-render/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Rendering Process in React</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <p>Even a component render, don’t means browser will repaint it. we get component, then component instance, then element, then VDOM, then DOM.</p> <h2 id="component-rendering-process">Component Rendering Process</h2> <p>Before your components are displayed on screen, they must be rendered by React.</p> <p>There are 3 steps for the whole rendering process:</p> <ol> <li>Triggering a render.</li> <li><strong>Rendering the component.</strong></li> <li>Committing to the DOM.</li> </ol> <h3 id="step-1-trigger-a-render">Step 1: Trigger a render</h3> <p>There are two reasons for a component to render:</p> <ul> <li>It’s the component’s initial render. By calling <code class="language-plaintext highlighter-rouge">createRoot</code> with the target DOM node, and then calling its render method with the component.</li> <li>The component’s (or one of its ancestors’) state has been updated. Updating the component’s state automatically queues a render. When prop or context be changed, it cause re-render as well.</li> </ul> <h3 id="step-2-react-renders-your-components">Step 2: React renders your components</h3> <blockquote class="block-warning"> <p>‘Rendering’ is React calling your components.</p> </blockquote> <ul> <li>On initial render, React will call the root component.</li> <li>For subsequent renders, React will <strong>call the function component</strong> whose state update triggered the render.</li> </ul> <blockquote class="block-warning"> <p>The default behavior of rendering will render all components nested within the updated component.</p> </blockquote> <p>This might be not optimal for performance if the updated component is very high in the tree. You can use <code class="language-plaintext highlighter-rouge">memo</code> and <code class="language-plaintext highlighter-rouge">useMemo</code> to avoid re-render the child components.</p> <h3 id="step-3-react-commits-changes-to-the-dom">Step 3: React commits changes to the DOM</h3> <p>After rendering (calling) your components, React will modify the DOM.</p> <ul> <li>For the initial render, React will use the appendChild() DOM API to put all the DOM nodes it has created on screen.</li> <li>For re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.</li> </ul> <p>React only changes the DOM nodes if there’s a difference between renders.</p> <p>After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion with React rendering.</p> <h2 id="check-if-component-is-re-rendered">Check if component is re-rendered</h2> <p>Re-render a component, means React execute that component function to calculate the output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">count</span><span class="o">++</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">component render number: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">count</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div> <p>But the component might be only invoked without rerendering. For example, you <code class="language-plaintext highlighter-rouge">setState()</code> to the same value as previous one, React will run the component function, but without rendering the children or firing effects.</p> <p>So the better way is to make a <code class="language-plaintext highlighter-rouge">useEffect</code> hook without a dependency array, this will make it run after each component render. Like code below can flicker the background when re-rendering:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// animation part</span>
  <span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">element</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent-flicker</span><span class="dl">"</span><span class="p">);</span>

    <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">element</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent-flicker</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">200</span><span class="p">);</span>
  <span class="p">});</span>
</code></pre></div></div> <h2 id="display-render-count-in-component">Display render count in component</h2> <p>You can’t use State, but you can use <strong>Ref</strong>!!</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="nx">props</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">renderCounter</span>  <span class="o">=</span> <span class="nf">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nf">useEffect </span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
      <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="na">Renders</span><span class="p">:</span> <span class="p">{</span><span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span><span class="p">},</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">};</span>
</code></pre></div></div> <h2 id="avoid-re-rendering-child-component">Avoid re-rendering child component</h2> <p>How to avoid re-rendering a nested child component when a parent component re-renders?</p> <h3 id="use-memory-api">Use Memory API</h3> <p>The basic way is using <code class="language-plaintext highlighter-rouge">React.memo</code> API. This can tell React avoid re-rendering child components. Most of the time you will use Hook <code class="language-plaintext highlighter-rouge">useMemo</code> and <code class="language-plaintext highlighter-rouge">useCallback</code> as well. More inforamtion at <a href="/blog/2023/memo-react/">Use Memory in React</a>.</p> <h3 id="lifting-content-up">lifting content up</h3> <p>The pattern of “lifting content up” has been used to avoid re-rendering a nested child component when a parent component re-renders. lifting content up means wrapping child component as <code class="language-plaintext highlighter-rouge">prop</code> and pass to parent component!</p> <h3 id="stop-re-rendering-of-child-which-consume-context">Stop re-rendering of child which consume Context</h3> <p>If context change, child should re-render. but if context don’t change, how to stop re-rendering? using <code class="language-plaintext highlighter-rouge">React.memo</code> API!</p> <h3 id="why-memory-function-can-stop-re-rendering">Why Memory function can stop re-rendering?</h3> <p>Because React is using <code class="language-plaintext highlighter-rouge">Object.is()</code> to make decision rendering or not.</p> <p>Memo function is used to memoize the result of the component. It returns the cached result when the same output occurs again. It will keep track of the previous <strong>prop’s value</strong> and compare it with the current value. If it detects changes, it will execute the child component again and re-evaluate it; if not, it will not execute it at all.</p> <h2 id="rendering-underhood">Rendering Underhood</h2> <h3 id="react-element">React Element</h3> <p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ele1</span> <span class="o">=&lt;</span><span class="nx">h1</span><span class="o">&gt;</span> <span class="nx">Hello</span><span class="p">,</span> <span class="nx">GFG</span> <span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="c1">// OR</span>
<span class="kd">const</span> <span class="nx">ele1</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">h1</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="nx">props</span><span class="p">},</span> <span class="dl">"</span><span class="s2">Hello, GFG</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">React.createElement()</code> function returns an object:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">h1</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hey Geek</span><span class="dl">'</span><span class="p">,</span>
            <span class="nx">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">header</span><span class="dl">'</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Normally, React elements is returned from React components. React don’t reuse element, it always destroy it and recreate it.</p> <h3 id="rendering-an-element-into-the-dom">Rendering an Element into the DOM</h3> <ul> <li>To Render an Element into the DOM, You need a root DOM node. <div class="language-ts highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">ReactDOM</span><span class="p">.</span><span class="nf">createRoot</span><span class="p">(</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">)</span>
<span class="p">);</span>
<span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">world</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="nx">root</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>To update the UI is to create a new element, and pass it to <code class="language-plaintext highlighter-rouge">root.render()</code>.</li> <li>ReactDom and React are same lib at version 13. React seperate them in order to support mare media, like ReactNative.</li> </ul> <h3 id="reconciliation">Reconciliation</h3> <p>Reconciliation is responsible for maintaining the tree of elements when a components prop or state change. Reconciliation houses the diffing algorithm that determines what parts of that tree need to be replaced.</p> <p>Here are some examples.</p> <ul> <li>When the React element’s type changed, React builds a whole new tree from scratch.</li> <li>React treat DOM element and component element differently.</li> <li>For children, like list, if you insert item at the end, React will check from the start and find it is same, the second is same and so on till the last one. And it will just add one item simply. BUT, if add item at start or middle, it can be expensive! React check the first one and find the difference, then it will destroy it and build new one, and second one is different and so on. It will destroy all and build again. So, React introduce <strong>key</strong> prop!</li> </ul> <h3 id="react-fiber">React Fiber</h3> <p>The actual rendering process is done by Ract Fiber.</p> <h2 id="fqa">FQA</h2> <ul> <li>How React render component with <code class="language-plaintext highlighter-rouge">key</code>?</li> <li>When re-render the component, is it means browser will re-paint the component? NO</li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Apr 4, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/react"> <i class="fas fa-tag fa-sm"></i> React</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/rendering"> <div class="tag"> Rendering </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#component-rendering-process"> # Component Rendering Process </a> </div> <div class="toc-item"> <a href="#check-if-component-is-re-rendered"> # Check if component is re-rendered </a> </div> <div class="toc-item"> <a href="#display-render-count-in-component"> # Display render count in component </a> </div> <div class="toc-item"> <a href="#avoid-re-rendering-child-component"> # Avoid re-rendering child component </a> </div> <div class="toc-item"> <a href="#rendering-underhood"> # Rendering Underhood </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>