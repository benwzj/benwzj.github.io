<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Python Function | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2024/py-function/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Python Function</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <h2 id="function-object">Function Object</h2> <h3 id="callable-object">Callable Object</h3> <h4 id="callable-object-including-following">Callable object including following:</h4> <ul> <li>user-defined functions,</li> <li>built-in functions,</li> <li>methods of built-in objects,</li> <li>class objects,</li> <li>methods of class instances,</li> <li>and all objects having a <code class="language-plaintext highlighter-rouge">__call__()</code> method are callable!</li> </ul> <h4 id="user-defined-functions-are-callable-objects">user-defined functions are callable objects</h4> <p>When you define a function, you are using user-defined function type (function class). Function object is instance of function type. All function type is callable type, support <code class="language-plaintext highlighter-rouge">__call__()</code>. You can define your own callable class:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> class Callable<span class="o">(</span>object<span class="o">)</span>:
...     def __init__<span class="o">(</span>self, name<span class="o">)</span>:
...         self.name <span class="o">=</span> name
...     def __call__<span class="o">(</span>self, greeting<span class="o">)</span>:
...         <span class="k">return</span> <span class="s1">'{}, {}!'</span>.format<span class="o">(</span>greeting, self.name<span class="o">)</span>
... 
<span class="o">&gt;&gt;&gt;</span> Callable<span class="o">(</span><span class="s1">'World'</span><span class="o">)(</span><span class="s1">'Hello'</span><span class="o">)</span>
<span class="s1">'Hello, World!'</span>
</code></pre></div></div> <h3 id="function-object-features">Function Object features:</h3> <ul> <li>user-defined Function objects are created by function definitions. The only operation on a function object is to call it: <code class="language-plaintext highlighter-rouge">func(argument-list)</code>.</li> <li>Functions are first class objects In Python, functions behave like any other object, such as an int or a list. That means that you can use functions as arguments to other functions, store functions as dictionary values, or return a function from another function.</li> <li>Two different function object types: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different.</li> <li>Python creates function objects for you when you use a def statement, or you use a lambda expression:</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> def foo<span class="o">()</span>: pass
... 
<span class="o">&gt;&gt;&gt;</span> foo
&lt;<span class="k">function </span>foo at 0x106aafd70&gt;
<span class="nb">type</span><span class="o">(</span>foo<span class="o">)</span>
&lt;class <span class="s1">'function'</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> lambda: None
&lt;<span class="k">function</span> &lt;lambda&gt; at 0x106d90668&gt;
</code></pre></div></div> <h3 id="user-defined-function-have-some-special-attributes">user-defined function have some Special attributes:</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">__name__</code>, The function’s name.</li> <li> <code class="language-plaintext highlighter-rouge">__module__</code>, The name of the module the function was defined in, or None if unavailable.</li> <li> <code class="language-plaintext highlighter-rouge">__code__</code>, The code object representing the compiled function body.</li> <li> <code class="language-plaintext highlighter-rouge">__globals__</code>, A reference to the dictionary that holds the function’s global variables</li> <li> <code class="language-plaintext highlighter-rouge">__dict__</code>, The namespace supporting arbitrary function attributes.</li> </ul> <h2 id="function-definitions">Function definitions</h2> <p>A function definition defines a user-defined function object.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">funcdef</span>  <span class="p">::</span><span class="o">=</span> <span class="p">[</span><span class="n">decorators</span><span class="p">]</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span> <span class="n">funcname</span> <span class="sh">"</span><span class="s">(</span><span class="sh">"</span> <span class="p">[</span><span class="n">parameter_list</span><span class="p">]</span> <span class="sh">"</span><span class="s">)</span><span class="sh">"</span>
               <span class="p">[</span><span class="sh">"</span><span class="s">-&gt;</span><span class="sh">"</span> <span class="n">expression</span><span class="p">]</span> <span class="sh">"</span><span class="s">:</span><span class="sh">"</span> <span class="n">suite</span>
</code></pre></div></div> <ul> <li>A function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function). This function object contains a reference to the current global namespace as the global namespace to be used when the function is called.</li> <li>The function definition does not execute the function body; this gets executed only when the function is called.</li> </ul> <h3 id="decorator">Decorator</h3> <ul> <li>Decorators are used to add some design patterns to a function without changing its structure.</li> <li>When a function returning another function, usually applied as a function transformation using the @wrapper syntax. This is Decorator.</li> <li>To apply a decorator we first define the decorator function.</li> <li>A function definition may be wrapped by one or more decorator expressions.</li> <li>Common examples for decorators are classmethod() and staticmethod().</li> <li>The decorator syntax is merely syntactic sugar, the following two function definitions are semantically equivalent:</li> </ul> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="bp">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div> <p>and</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div></div> <h4 id="example">Example</h4> <p>we have a decorator function:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">uppercase_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nf">function</span><span class="p">()</span>
        <span class="n">make_uppercase</span> <span class="o">=</span> <span class="n">func</span><span class="p">.</span><span class="nf">upper</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">make_uppercase</span>

    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <p>Option1:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">say_hi</span><span class="p">():</span>
    <span class="k">return</span> <span class="sh">'</span><span class="s">hello there</span><span class="sh">'</span>

<span class="n">decorate</span> <span class="o">=</span> <span class="nf">uppercase_decorator</span><span class="p">(</span><span class="n">say_hi</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">decorate</span><span class="p">())</span> 
<span class="c1">#print HELLO THERE
</span></code></pre></div></div> <p>Option2:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@uppercase_decorator</span>
<span class="k">def</span> <span class="nf">say_hi</span><span class="p">():</span>
    <span class="k">return</span> <span class="sh">'</span><span class="s">hello there</span><span class="sh">'</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">say_hi</span><span class="p">())</span>
<span class="c1">#print HELLO THERE
</span></code></pre></div></div> <h3 id="annotation">Annotation</h3> <p>Function annotations are arbitrary python expressions that are associated with various part of functions. These expressions are evaluated at compile time and have no life in python’s runtime environment. Python does not attach any meaning to these annotations.</p> <ul> <li>Function annotations take life only when interpreted by third party libraries, for example, mypy.</li> <li>Python supports dynamic typing and hence no module is provided for type checking. Annotations can provide more information.</li> <li>Support simple parameters, excess parameters, nested parameters, return type.</li> <li>Type annotations introduced in Python 3.0</li> <li>Special attribute <code class="language-plaintext highlighter-rouge">‘__annotations__’</code> outputs the dictionary having a special key <code class="language-plaintext highlighter-rouge">‘return’</code> and other keys having name of the annotated arguments.</li> <li>standard library pydoc, inspect can provide information of all the annotation of a module.</li> </ul> <h4 id="type-hints">Type hints</h4> <p>Annotations were introduced in Python 3.0 originally without any specific purpose. They were simply a way to associate arbitrary expressions to function arguments and return values. Years later, PEP 484 defined how to add type hints to your Python code, based off work that Jukka Lehtosalo had done on his Ph.D. project, Mypy.</p> <ul> <li>Python 3.5 introduced Lib/typing.py (type hints), which you can add to your code using the type annotations introduced in Python 3.0.</li> <li>Now The main purpose of annotation is to add type hints.</li> <li>lib/typing.py — Support for type hints</li> </ul> <h2 id="parameter-argument">Parameter, argument</h2> <p>Parameter refer to reference which appear on the funciton definition. Argument refer to the value which provided for function when it was bind</p> <h3 id="basic-concepts">Basic concepts</h3> <h4 id="python-supports-5-types-of-arguments">Python supports 5 types of arguments:</h4> <ul> <li>Positional arguments.</li> <li>Keyword arguments.</li> <li>Any number of positional arguments (*args)</li> <li>Any number of keyword arguments (**kwargs)</li> <li>Default arguments.</li> </ul> <p>We could define our own function parameters in a way that restricts them to only accept positional arguments, or only keyword arguments by using the characters / and *.</p> <h4 id="by-default">By default</h4> <p>a function must be called with the correct number of arguments. (this is different from JavaScript)</p> <h4 id="positional-arguments">Positional arguments</h4> <p>Arguments that match up parameters based on their position in the invocation expression are called positional arguments.</p> <ul> <li>Python will resolve all the arguments to positional arguments.</li> </ul> <h4 id="keyword-arguments">Keyword Arguments</h4> <p>send arguments with the key = value syntax. This way the order of the arguments does not matter. (JavaScript is not support this feature) def my_function(child3, child2, child1): print(“The youngest child is “ + child3)</p> <p>my_function(child1 = “Emil”, child2 = “Tobias”, child3 = “Linus”)</p> <h4 id="-args">* args</h4> <p>add a * before the parameter name on definition.</p> <ul> <li> <p>This way the function will receive a tuple of arguments, and can access the items accordingly by position. def my_function(*kids): print(“The youngest child is “ + kids[2])</p> </li> <li> <p>Parameters after *args are keyword-only.</p> </li> </ul> <h4 id="kwargs">**kwargs</h4> <p>add two asterisk: ** before the parameter name in the function definition.</p> <p>This way the function will receive a dictionary of arguments, and can access the items accordingly by key:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="o">**</span><span class="n">kid</span><span class="p">):</span>
  <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">His last name is </span><span class="sh">"</span> <span class="o">+</span> <span class="n">kid</span><span class="p">[</span><span class="sh">"</span><span class="s">lname</span><span class="sh">"</span><span class="p">])</span>

<span class="nf">my_function</span><span class="p">(</span><span class="n">fname</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Tobias</span><span class="sh">"</span><span class="p">,</span> <span class="n">lname</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Refsnes</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">**kwargs</code> must be the last parameter.</p> <h4 id="default-parameter-value">Default Parameter Value</h4> <p>When one or more parameters have the form parameter = expression, the function is said to have “default parameter values.” For a parameter with a default value, the corresponding argument may be omitted from a call, in which case the parameter’s default value is substituted:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">country</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Norway</span><span class="sh">"</span><span class="p">):</span>
  <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">I am from </span><span class="sh">"</span> <span class="o">+</span> <span class="n">country</span><span class="p">)</span>

<span class="nf">my_function</span><span class="p">()</span>
</code></pre></div></div> <p>If a parameter has a default value, all following parameters up until the “*” must also have a default value — this is a syntactic restriction that is not expressed by the grammar.</p> <p>Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter value is a mutable object, such as a list or a dictionary. if the function modifies the object, the default parameter value is in effect modified. This is generally not what was intended. So, DO NOT set mutable type as Default value.</p> <p>Example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">6</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1"># print 5
</span></code></pre></div></div> <p>Another one:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nf">f</span><span class="p">()</span>
<span class="nf">f</span><span class="p">()</span>
<span class="nf">f</span><span class="p">([</span><span class="mi">99</span><span class="p">])</span>
<span class="nf">f</span><span class="p">()</span>

<span class="c1"># Print: 
# [1, 2, 3, 1]
# [1, 2, 3, 1, 1]
# [99, 1]
# [1, 2, 3, 1, 1, 1]
</span></code></pre></div></div> <p>Try not to set default parameter value as mutable object. Instead, Using following:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_parameter_function</span><span class="p">(</span><span class="n">lst</span> <span class="o">=</span> <span class="n">none</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="n">none</span><span class="p">:</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># ...
</span></code></pre></div></div> <h3 id="all-argument-expressions-are-evaluated-before-the-call-is-attempted">All argument expressions are evaluated before the call is attempted.</h3> <p>All keyword arguments have to follow all positional arguments. That means all positional arguments provide first, then the keyword argument.</p> <h4 id="if-keyword-arguments-are-present-they-are-first-converted-to-positional-arguments">If keyword arguments are present, they are first converted to positional arguments.</h4> <ul> <li>First, a list of unfilled slots is created for the formal parameters. If there are N positional arguments, they are placed in the first N slots.</li> <li>Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on). If the slot is already filled, a TypeError exception is raised. Otherwise, the value of the argument is placed in the slot, filling it (even if the expression is None, it fills the slot).</li> <li>When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition. (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don’t specify an argument value for the corresponding slot; this should usually be avoided.)</li> <li>If there are any unfilled slots for which no default value is specified, a TypeError exception is raised. Otherwise, the list of filled slots is used as the argument list for the call.</li> </ul> <h4 id="expression-argument-implementation-detail">*expression argument implementation detail</h4> <p>If the syntax *expression appears in the function call, expression must evaluate to an iterable. Elements from these iterables are treated as if they were additional positional arguments. For the call f(x1, x2, *y, x3, x4), if y evaluates to a sequence y1, …, yM, this is equivalent to a call with M+4 positional arguments x1, x2, y1, …, yM, x3, x4.</p> <p>A consequence of this is that although the *expression syntax may appear after explicit keyword arguments, it is processed before the keyword arguments (and any **expression arguments). So:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> def f<span class="o">(</span>a, b<span class="o">)</span>:
...     print<span class="o">(</span>a, b<span class="o">)</span>
...
<span class="o">&gt;&gt;&gt;</span> f<span class="o">(</span><span class="nv">b</span><span class="o">=</span>1, <span class="k">*</span><span class="o">(</span>2,<span class="o">))</span>
2 1
<span class="o">&gt;&gt;&gt;</span> f<span class="o">(</span><span class="nv">a</span><span class="o">=</span>1, <span class="k">*</span><span class="o">(</span>2,<span class="o">))</span>
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"&lt;stdin&gt;"</span>, line 1, <span class="k">in</span> &lt;module&gt;
TypeError: f<span class="o">()</span> got multiple values <span class="k">for </span>keyword argument <span class="s1">'a'</span>
<span class="o">&gt;&gt;&gt;</span> f<span class="o">(</span>1, <span class="k">*</span><span class="o">(</span>2,<span class="o">))</span>
1 2
</code></pre></div></div> <h4 id="expression-argument">**expression argument</h4> <p>If the syntax **expression appears in the function call, expression must evaluate to a mapping, the contents of which are treated as additional keyword arguments. If a keyword is already present (as an explicit keyword argument, or from another unpacking), a TypeError exception is raised.</p> <h3 id="what-do-single-slash--asterisk--means-in-parameter">What do single slash /, asterisk * means in parameter.</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func_name</span><span class="p">(</span><span class="n">pos_only</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">pos_or_keyword</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keyword_only</span><span class="p">):</span>
    <span class="c1"># function body
</span></code></pre></div></div> <ul> <li>slash <code class="language-plaintext highlighter-rouge">/</code> denotes that the parameters prior to it are positional-only.</li> <li>asterisk * denotes that after <em>, it accept more optional arguments which must be specified as keyword arguments, but no positional arguments is accepted. (</em>args have same effect as *, it accept keyword arguments only after *args)</li> <li>e.g. built-in sorted function: <code class="language-plaintext highlighter-rouge">sorted(iterable, /, *, key=None, reverse=False)</code> </li> <li>e.g. sum built-in function:<code class="language-plaintext highlighter-rouge">sum(iterable, /, start=0)</code>. sum accept up to 2 arguments, the second one don’t have to be keyword argument.</li> </ul> <h2 id="return-value">Return value</h2> <p>A call always returns some value, possibly None, unless it raises an exception. How this value is computed depends on the type of the callable object. If it is</p> <ul> <li>a user-defined function: The code block for the function is executed, passing it the argument list. The first thing the code block will do is bind the formal parameters to the arguments; this is described in section Function definitions. When the code block executes a return statement, this specifies the return value of the function call.</li> <li>a built-in function or method: The result is up to the interpreter; see Built-in Functions for the descriptions of built-in functions and methods.</li> <li>a class object: A new instance of that class is returned.</li> <li>a class instance method: The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument.</li> <li>a class instance: The class must define a <code class="language-plaintext highlighter-rouge">__call__()</code> method; the effect is then the same as if that method was called.</li> </ul> <h2 id="lambda">Lambda</h2> <p>A lambda function is a small anonymous function. A lambda function can take any number of arguments, but can only have one expression.</p> <p>The expression lambda parameters: expression yields a function object. The unnamed object behaves like a function object defined with:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="err">&lt;</span><span class="nf">lambda</span><span class="o">&gt;</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</code></pre></div></div> <p>Note that functions created with lambda expressions cannot contain statements or annotations.</p> <h3 id="name-of-lambda">Name of lambda</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
<span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">__code__</span><span class="p">.</span><span class="n">co_name</span><span class="p">)</span> <span class="c1"># &lt;lambda&gt;
</span></code></pre></div></div> <p>The word <code class="language-plaintext highlighter-rouge">'&lt;lambda&gt;'</code> can’t be the name of a normal function in Python, since it contains two invalid characters: &lt; and &gt;.</p> <h3 id="why-lambda">Why lambda</h3> <p>The power of lambda is better shown when you use them as an anonymous function inside another function.</p> <h3 id="how-to-use-lambda">How to use lambda</h3> <p>don’t need return keyword.</p> <p>Just like curry function in JavaScript:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span> <span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">n</span>

<span class="n">mydoubler</span> <span class="o">=</span> <span class="nf">myfunc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mytripler</span> <span class="o">=</span> <span class="nf">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">mydoubler</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">mytripler</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
</code></pre></div></div> <p>Or same as high order function:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> student_tuples <span class="o">=</span> <span class="o">[</span>
...     <span class="o">(</span><span class="s1">'john'</span>, <span class="s1">'A'</span>, 15<span class="o">)</span>,
...     <span class="o">(</span><span class="s1">'jane'</span>, <span class="s1">'B'</span>, 12<span class="o">)</span>,
...     <span class="o">(</span><span class="s1">'dave'</span>, <span class="s1">'B'</span>, 10<span class="o">)</span>,
... <span class="o">]</span>
<span class="o">&gt;&gt;&gt;</span> sorted<span class="o">(</span>student_tuples, <span class="nv">key</span><span class="o">=</span>lambda student: student[2]<span class="o">)</span>   <span class="c"># sort by age</span>
<span class="o">[(</span><span class="s1">'dave'</span>, <span class="s1">'B'</span>, 10<span class="o">)</span>, <span class="o">(</span><span class="s1">'jane'</span>, <span class="s1">'B'</span>, 12<span class="o">)</span>, <span class="o">(</span><span class="s1">'john'</span>, <span class="s1">'A'</span>, 15<span class="o">)]</span>
</code></pre></div></div> <h2 id="scopes-and-namespaces">Scopes and Namespaces</h2> <p>Namespace is the mapping from names to objects. Scope is the available variables in the specific area.</p> <h3 id="namespaces">Namespaces</h3> <ul> <li>A namespace is a mapping from names to objects.</li> <li>In a sense the set of attributes of an object also form a namespace.</li> </ul> <p>Namespaces are created at different moments and have different lifetimes:</p> <ul> <li>The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted.</li> <li>The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits.</li> <li>The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Of course, recursive invocations each have their own local namespace.)</li> </ul> <h3 id="scopes">Scopes</h3> <h4 id="what-is-scope">What is Scope</h4> <ul> <li>A scope is a region of code where a given set of name bindings is accessible.</li> <li>A scope can be thought of as an area in a script where given variables are available.</li> <li>A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.</li> <li>Although scopes are determined statically, they are used dynamically.</li> </ul> <h4 id="how-scope-works">How Scope works</h4> <p>Python follows the LEGB rule to determine what value to resolve a variable with when it’s encountered, or whether to throw an error.</p> <p>LEGB stands for Local, Enclosing, Global and Built-in. This rule simply states the order of scopes in which Python searches for the existence of a given variable.</p> <p>At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:</p> <ul> <li>the innermost scope, which is searched first, contains the local names</li> <li>the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names</li> <li>the next-to-last scope contains the current module’s global names</li> <li>the outermost scope (searched last) is the namespace containing built-in names</li> </ul> <p><code class="language-plaintext highlighter-rouge">global</code> or <code class="language-plaintext highlighter-rouge">nonlocal</code> statement affect the Scopes</p> <ul> <li>The global statement can be used to indicate that particular variables live in the global scope and should be rebound there;</li> <li>The nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there.</li> </ul> <h3 id="example-1">Example</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="sh">"</span><span class="s">local spam</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="sh">"</span><span class="s">nonlocal spam</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="sh">"</span><span class="s">global spam</span><span class="sh">"</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="sh">"</span><span class="s">test spam</span><span class="sh">"</span>
    <span class="nf">do_local</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">After local assignment:</span><span class="sh">"</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="nf">do_nonlocal</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">After nonlocal assignment:</span><span class="sh">"</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="nf">do_global</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">After global assignment:</span><span class="sh">"</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="nf">scope_test</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">In global scope:</span><span class="sh">"</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</code></pre></div></div> <p>The output of the example code is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</code></pre></div></div> <h3 id="python-is-a-lexically-scoped-language">Python is a lexically-scoped language</h3> <p>(Lexically-scoped also known as statically-scoped. ) Many modern programming languages including C, Python, JavaScript, etc. are lexically-scoped languages. They work on a lexical-scoping model.</p> <p>Lexical-scoping implies the fact that names are accessible only where they are defined, not anywhere else.</p> <p>It means that a name is available only in its lexical context i.e the place where it is defined in the source code, not in the calling context (also known as dynamic context).</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="nf">f1</span><span class="p">()</span>

<span class="nf">f2</span><span class="p">()</span><span class="c1"># 10
</span></code></pre></div></div> <p>The word ‘lexical’ means ‘source code’</p> <h4 id="what-exactly-is-meant-by-the-term-context">What exactly is meant by the term ‘context’.</h4> <p>At any given point in a piece of code, the set of all names available is known as a context. A context is sometimes also referred to as an environment.</p> <p>lexical context example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># outer lexical context of f()
</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># local lexical context
</span>    <span class="n">c</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">40</span>
</code></pre></div></div> <p>In contrast, a dynamic context, or an execution context, depends upon the state of a program i.e a particular stage of its execution.</p> <h2 id="code-object">Code Object</h2> <h3 id="what-is-code-object">What is Code object</h3> <p>Code objects are a low-level detail of the CPython implementation. Each one represents a chunk of executable code that hasn’t yet been bound into a function. Code objects represent byte-compiled executable Python code, or bytecode.</p> <h4 id="the-difference-between-a-code-object-and-a-function-object">The difference between a code object and a function object</h4> <p>is that the function object contains an explicit reference to the function’s globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time). Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects.</p> <h4 id="built-in-function-compile-return-code-object">built-in function <code class="language-plaintext highlighter-rouge">compile()</code> return code object.</h4> <p>example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">code_str</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
print(</span><span class="sh">"</span><span class="s">Hello Code Objects</span><span class="sh">"</span><span class="s">)
</span><span class="sh">"""</span>
<span class="c1"># Create the code object
</span><span class="n">code_obj</span> <span class="o">=</span> <span class="nf">compile</span><span class="p">(</span><span class="n">code_str</span><span class="p">,</span> <span class="sh">'</span><span class="s">&lt;string&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">exec</span><span class="sh">'</span><span class="p">)</span>
<span class="c1"># get the code object
</span><span class="nf">print</span><span class="p">(</span><span class="n">code_obj</span><span class="p">)</span>
<span class="c1">#Attributes of code object
</span><span class="nf">print</span><span class="p">(</span><span class="nf">dir</span><span class="p">(</span><span class="n">code_obj</span><span class="p">))</span>
<span class="c1"># The filename
</span><span class="nf">print</span><span class="p">(</span><span class="n">code_obj</span><span class="p">.</span><span class="n">co_filename</span><span class="p">)</span>
<span class="c1"># The first chunk of raw bytecode
</span><span class="nf">print</span><span class="p">(</span><span class="n">code_obj</span><span class="p">.</span><span class="n">co_code</span><span class="p">)</span>
<span class="c1">#The variable Names
</span><span class="nf">print</span><span class="p">(</span><span class="n">code_obj</span><span class="p">.</span><span class="n">co_varnames</span><span class="p">)</span>
</code></pre></div></div> <h3 id="what-is-code-object-of-function">What is Code object of function</h3> <p>A code object describes different aspects of a compiled function, based on its byte code.</p> <ul> <li>They expose various details about a function such as the number of positional arguments it must have; the number of its local variables; its free variables;</li> <li>Every function in Python has a <code class="language-plaintext highlighter-rouge">__code__</code> attribute that holds its code object.</li> </ul> <h3 id="some-attributes-of-code-object">Some attributes of code object.</h3> <p><code class="language-plaintext highlighter-rouge">co_nlocals</code> — is the number of local variables used by the function (including arguments). <code class="language-plaintext highlighter-rouge">co_argcount</code> — is the total number of positional arguments (including positional-only arguments and arguments with default values). <code class="language-plaintext highlighter-rouge">co_varnames</code> — is a tuple containing the names of the local variables (starting with the argument names). <code class="language-plaintext highlighter-rouge">co_names</code> — is a tuple containing the names used by the bytecode. <code class="language-plaintext highlighter-rouge">co_cellvars</code> — is a tuple containing the names of local variables that are referenced by nested functions. <code class="language-plaintext highlighter-rouge">co_freevars</code> — is a tuple containing the names of free variables; co_code is a string representing the sequence of bytecode instructions.</p> <h4 id="free-variable">Free variable</h4> <p>Any non-local, non-global, variable used by a function is referred to as a free variable of the function. x is free variable for bar function at following:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bar</span>

<span class="n">bar_fun</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">bar_fun</span><span class="p">.</span><span class="n">__code__</span><span class="p">.</span><span class="n">co_freevars</span><span class="p">)</span> <span class="c1">#('x',)
</span></code></pre></div></div> <h4 id="cell-variable">cell variable</h4> <p>For a given function, a cell variable is a local variable that is used by a nested function.</p> <p>A cell variable is an idea related to that of a free variable. If a variable x is a free variable for a function bar then that same variable would be a cell variable for a function foo:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bar</span>

<span class="n">bar_fun</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">__code__</span><span class="p">.</span><span class="n">co_cellvars</span><span class="p">)</span> <span class="c1">#('x',)
</span></code></pre></div></div> <h2 id="closure">Closure</h2> <h3 id="what-is-closure">What is closure</h3> <p>A function along with the environment of its enclosing function, are collectively referred to as a closure. (The concept of closure is same with JavaScript. But the implementation should be different)</p> <ul> <li>We can nest functions within functions in Python. Moreover, the inner function might additionally use data defined inside the outer function.</li> <li>A function returned from another function that uses one of its local variables, is a closure.</li> <li>But Essentially, any function that captures its enclosing environment inside its <code class="language-plaintext highlighter-rouge">__closure__</code> attribute is a closure. It don’t have to be returned function (that guy said so).</li> </ul> <h3 id="how-to-implement-closure">How to implement closure</h3> <h4 id="it-is-important-to-understand-cell-variable-and-free-variable">It is important to understand cell variable and free variable</h4> <ul> <li>A local variable is referred to as a cell variable of the function if it’s used by an inner (nested) function. A cell variable, therefore, is simply a variable used in multiple scopes.</li> <li>A free variable is a variable not defined in the local scope of the function, neither a parameter, nor a global. a free variable is a non-local variable of a function, defined in an outer function.</li> </ul> <h4 id="co_freevars-attribute">co_freevars attribute</h4> <p>For a given function, its code object contains a co_freevars attribute that contains the names of all the free variables of the function.</p> <h4 id="__closure__-attribute"> <code class="language-plaintext highlighter-rouge">__closure__</code> attribute</h4> <p>Its <code class="language-plaintext highlighter-rouge">__closure__</code> attribute contains a tuple holding the values of each of its free variables; or else the value None. the co_freevars attribute of the function’s code object holds the names of all free variables, while the <code class="language-plaintext highlighter-rouge">__closure__</code> attribute holds their values. And these valueis cell object:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">bar</span>

<span class="n">bar</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="n">bar</span><span class="p">.</span><span class="n">__closure__</span>
<span class="p">(</span><span class="o">&lt;</span><span class="n">cell</span> <span class="n">at</span> <span class="mh">0x7f9d64c68460</span><span class="p">:</span> <span class="nb">int</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x954f40</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">cell</span> <span class="n">at</span> <span class="mh">0x7f9d643a4eb0</span><span class="p">:</span> <span class="nb">int</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x955080</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">__closure__</code> attribute holds tuple of cell objects — each corresponding to a free variable.</p> <h4 id="what-is-cell-object">What is cell object</h4> <p>“Cell” objects are used to implement variables referenced by multiple scopes. For each such variable, a cell object is created to store the value; the local variables of each stack frame that references the value contains a reference to the cells from outer scopes which also use that variable.</p> <p>When the value is accessed, the value contained in the cell is used instead of the cell object itself. This de-referencing of the cell object requires support from the generated byte-code; these are not automatically de-referenced when accessed.</p> <p>Cell objects are not likely to be useful elsewhere.</p> <h2 id="faq">FAQ</h2> <ul> <li>The difference between namespace and scope concept</li> <li>What is the class for Function object?</li> </ul> <h3 id="what-is-the-relationship-between-function-and-method">What is the relationship between function and method</h3> <p>Methods are functions that are called using the attribute notation.</p> <ul> <li>If you access a method (a function defined in a class namespace) through an instance, you get a special object: a bound method object.</li> <li>When method is called, it will add the self argument to the argument list. Bound methods have two special read-only attributes: <code class="language-plaintext highlighter-rouge">m.__self__</code> is the object on which the method operates, and <code class="language-plaintext highlighter-rouge">m.__func__</code> is the function implementing the method. Calling m(arg-1, arg-2, …, arg-n) is completely equivalent to calling <code class="language-plaintext highlighter-rouge">m.__func__</code>(<code class="language-plaintext highlighter-rouge">m.__self__</code>, arg-1, arg-2, …, arg-n).</li> </ul> <h3 id="what-is-code-objects">What is Code Objects?</h3> <p>Code objects are returned by the built-in compile() function and can be extracted from function objects through their <code class="language-plaintext highlighter-rouge">__code__</code> attribute.</p> <p>Code objects are used by the implementation to represent “pseudo-compiled” executable Python code such as a function body. They differ from function objects because they don’t contain a reference to their global execution environment.</p> <h3 id="what-is-happening-for-the-following-code">What is happening for the following code?</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="p">[]):</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">print</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">print</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">print</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">print</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="k">print</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">print</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div> <p>Binding of default arguments occurs at function definition. Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter value is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default parameter value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">whats_on_the_telly</span><span class="p">(</span><span class="n">penguin</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">penguin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">penguin</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">penguin</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">"</span><span class="s">property of the zoo</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">penguin</span>
</code></pre></div></div> <h3 id="whats-type-hinting">What’s Type Hinting</h3> <p>Type hinting in Python is basically declaring that the parameters in your functions and methods have a certain type. example: Normal function:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <p>function with type hinting:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div> <h3 id="what-is-variable-annotation">What is Variable Annotation</h3> <p>Let’s say you want to not just annotate function parameters but also regular variables. from typing import List</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">odd_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="n">odd</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># this is variable annotation
</span>    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">odd</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">odd</span>
</code></pre></div></div> <h3 id="nonlocal-concept">nonlocal concept</h3> <h4 id="in-python">In Python,</h4> <p>The nonlocal statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals. This is important because the default behavior for binding is to search the local namespace first. The nonlocal statement allows encapsulated code to rebind variables outside of the local scope besides the global (module) scope.</p> <p>Following is a nested function inner defined in the scope of another function outer. The variable x is local to outer, but non-local to inner (nor is it global):</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
</code></pre></div></div> <h4 id="in-javascript">In Javascript</h4> <p>In Javascript, the locality of a variable is determined by the closest var statement for this variable. In the following example, x is local to outer as it contains a var x statement, while inner doesn’t. Therefore, x is non-local to inner:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nf">inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">inner</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Dec 25, 2024</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/python"> <i class="fas fa-tag fa-sm"></i> Python</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/python"> <div class="tag"> Python </div> </a> <a href="/blog/tag/function"> <div class="tag"> Function </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#function-object"> # Function Object </a> </div> <div class="toc-item"> <a href="#function-definitions"> # Function definitions </a> </div> <div class="toc-item"> <a href="#parameter-argument"> # Parameter, argument </a> </div> <div class="toc-item"> <a href="#return-value"> # Return value </a> </div> <div class="toc-item"> <a href="#lambda"> # Lambda </a> </div> <div class="toc-item"> <a href="#scopes-and-namespaces"> # Scopes and Namespaces </a> </div> <div class="toc-item"> <a href="#code-object"> # Code Object </a> </div> <div class="toc-item"> <a href="#closure"> # Closure </a> </div> <div class="toc-item"> <a href="#faq"> # FAQ </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>