<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>React State system | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2023/react-state/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">React State system</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <h2 id="understand-state-in-react">Understand State in React</h2> <h3 id="state-behaves-as-snapshot">State behaves as snapshot</h3> <p>States are a component’s memory. State actually “lives” in React itself (as if on a shelf!) outside of your function. When triggering a render, React calls your component, it gives you a snapshot of the state for that particular render.</p> <p>This snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</p> <p>But how to understand this component:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">setCounter</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">setCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
    <span class="nf">setCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span>
        <span class="nx">counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">counter</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="nx">add</span> <span class="nx">it</span>     
      <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nf">delay</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// It will display "counter: -1" when click the button.</span>
</code></pre></div></div> <p>It still make sense like this: When you click, cause a re-render, React return a second snapshot: <code class="language-plaintext highlighter-rouge">counter: 1</code> for the new render; After 3 seconds, <code class="language-plaintext highlighter-rouge">setCounter(counter - 1);</code> executed and trigger a new render as well but this code is executed based on the old snapshot: <code class="language-plaintext highlighter-rouge">counter: 0</code>. It still trigger a render and create a new snapshot: <code class="language-plaintext highlighter-rouge">counter: -1</code>; In this case, React just manage one memory for this component because it is in the same place.</p> <blockquote class="block-warning"> <p>So, Don’t read the latest state from an asynchronous operation, like a timeout. It is confused!</p> </blockquote> <h3 id="state-vs-ref">State vs Ref</h3> <p>State and Ref are comparable. React use them for different purpose.</p> <ul> <li>Mutating <code class="language-plaintext highlighter-rouge">state</code> cause re-render. Mutating <code class="language-plaintext highlighter-rouge">ref</code> won’t.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">ref</code> could point to anything: a string, an object, or even a function.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">refs</code> both are live outside of your component.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">refs</code> both are retained by React between re-renders.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> works as snapshot for each render; But <code class="language-plaintext highlighter-rouge">ref</code> won’t be affected by render.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> is ”Immutable” — you must use the state setting function to modify state variables to queue a re-render; <code class="language-plaintext highlighter-rouge">ref</code> is mutable, it is a <strong>plain</strong> JavaScript object that you can read and modify.</li> <li>You shouldn’t read (or write) the <code class="language-plaintext highlighter-rouge">ref.current</code> value during rendering. But You can read <code class="language-plaintext highlighter-rouge">state</code> any time.</li> <li>You aren’t supposed to read <code class="language-plaintext highlighter-rouge">state</code> in asynchronous manner(because easily confused); But you can handle <code class="language-plaintext highlighter-rouge">ref</code> asynchronously.</li> </ul> <h2 id="state-rules">State Rules</h2> <ul> <li>Treat all state in React as <strong>immutable</strong>. This help React run very fast.</li> <li>State behaves as a <strong>snapshot</strong>. Setting state does not change the state variable you already have, but instead triggers a re-render.</li> <li>State actually “lives” in React itself outside of your function.</li> <li>When triggering a render, React calls your component, it gives you a snapshot of the state for that particular render.</li> <li>This new snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</li> <li>React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison.</li> <li>You can store information from previous renders, but need to use condition, and also, the logic is hard to read. try to avoid.</li> <li>When you call the <code class="language-plaintext highlighter-rouge">set</code> function of useState hook during render, React will re-render that component immediately after your component exits with a <code class="language-plaintext highlighter-rouge">return</code> statement, and before rendering the children.</li> <li>Unlike props, state is fully private to the component declaring it. If you render the same component twice, each copy will have completely isolated state!</li> <li>React batches state updates, it will queue all set functions and execute all set functions one by one before re-render.</li> </ul> <h2 id="usestate-hook">useState Hook</h2> <h3 id="syntax">Syntax</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
</code></pre></div></div> <p>useState returns an array with exactly two items:</p> <ol> <li>The current state of this state variable, initially set to the initial state you provided.</li> <li>The set function that lets you change it to any other value in response to interaction.</li> </ol> <p>Important to Know:</p> <ol> <li>Calling the set function does not change the current state in the already executing code.</li> <li>State is considered read-only, When state is objects or arrays, you should replace it rather than mutate your existing objects.</li> <li>About the initial state, React saves it once and ignores it on the next renders. So don’t do this: <code class="language-plaintext highlighter-rouge">const [todos, setTodos] = useState(createInitialTodos());</code>, because React run this function every render and means nothing. But you can do this: <code class="language-plaintext highlighter-rouge">const [todos, setTodos] = useState(createInitialTodos);</code>.</li> </ol> <h3 id="how-react-implement-usestate-hook">How React implement <code class="language-plaintext highlighter-rouge">useState</code> Hook</h3> <p>It is helpful to know How <code class="language-plaintext highlighter-rouge">useState</code> works inside React. Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to 0 before rendering. Each time you call useState, React gives you the next state pair and increments the index. Hooks rely on a stable call <strong>order</strong> on every render of the same component. Roughly like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">componentHooks</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">currentHookIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">componentHooks</span><span class="p">[</span><span class="nx">currentHookIndex</span><span class="p">];</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This is not the first render,</span>
    <span class="c1">// so the state pair already exists.</span>
    <span class="c1">// Return it and prepare for next Hook call.</span>
    <span class="nx">currentHookIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">pair</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This is the first time we're rendering,</span>
  <span class="c1">// so create a state pair and store it.</span>
  <span class="nx">pair</span> <span class="o">=</span> <span class="p">[</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">setState</span><span class="p">];</span>

  <span class="kd">function</span> <span class="nf">setState</span><span class="p">(</span><span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// When the user requests a state change,</span>
    <span class="c1">// put the new value into the pair.</span>
    <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextState</span><span class="p">;</span>
    <span class="nf">updateDOM</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Store the pair for future renders</span>
  <span class="c1">// and prepare for the next Hook call.</span>
  <span class="nx">componentHooks</span><span class="p">[</span><span class="nx">currentHookIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pair</span><span class="p">;</span>
  <span class="nx">currentHookIndex</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">pair</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="how-about-setstate">How about <code class="language-plaintext highlighter-rouge">setState</code> </h3> <p>The set function returned by <code class="language-plaintext highlighter-rouge">useState</code> lets you update the state to a different value and trigger a re-render.</p> <p>You can pass the next <strong>state value</strong> directly, OR a <strong>‘updater function’</strong> that calculates it from the previous state. Because <strong>React batches state updates</strong>, it will queue all these set functions and execute all these set functions one by one before re-render. React will treat updater function differently from direct value (<code class="language-plaintext highlighter-rouge">baseState</code> is current value; <code class="language-plaintext highlighter-rouge">queue</code> is setfunctions array) :</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nf">getFinalState</span><span class="p">(</span><span class="nx">baseState</span><span class="p">,</span> <span class="nx">queue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">finalState</span> <span class="o">=</span> <span class="nx">baseState</span><span class="p">;</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">updater</span> <span class="k">of</span> <span class="nx">queue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">updater</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Apply the updater function.</span>
      <span class="nx">finalState</span> <span class="o">=</span> <span class="nf">updater</span><span class="p">(</span><span class="nx">finalState</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Replace the next state.</span>
      <span class="nx">finalState</span> <span class="o">=</span> <span class="nx">updater</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">finalState</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>The <strong>order</strong> is matter! React execute the setState functions in exact order.</li> <li>The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call. It is Async.</li> <li> <p>If the new value you provide is identical to the current state, as determined by an <code class="language-plaintext highlighter-rouge">Object.is</code> comparison, React will skip re-rendering the component and its children.</p> </li> <li>Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders.</li> <li>In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production.</li> </ul> <h3 id="set-state-to-a-function">Set State to a function</h3> <p>Don’t do this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">setFn</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">someFunction</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setFn</span><span class="p">(</span><span class="nx">someOtherFunction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put <code class="language-plaintext highlighter-rouge">()=&gt;</code> before them in both cases. Then React will store the functions you pass.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">setFn</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">someFunction</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setFn</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">someOtherFunction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>The different between <code class="language-plaintext highlighter-rouge">someFunction</code> and <code class="language-plaintext highlighter-rouge">()=&gt;someFunction</code> is that, executing latter will return former.</p> </blockquote> <h2 id="fqa">FQA</h2> <h3 id="how-to-handle-object-and-array-state">How to handle Object and Array STATE?</h3> <p>Keep stick to this rule: <strong>Treat all state as immutable</strong>. Object and Array is mutable, but we need to handle it asif it is immutable.</p> <h4 id="here-are-some-ways-to-handle-object-state">Here are some ways to handle Object state:</h4> <ul> <li>Copying objects with the <strong>spread syntax</strong>. Like this: ` {…obj, something: ‘newValue’}` object spread syntax to create copies of objects. But Spread syntax is shallow.</li> <li>Using <code class="language-plaintext highlighter-rouge">Immer</code> module for nested object state is a choice. (I don’t recommend Immer, because it looks like break the rule and make thing confused.)</li> <li>Create a new array from the original array in your state by calling its non-mutating methods like <code class="language-plaintext highlighter-rouge">filter()</code> (Removing from an array) and <code class="language-plaintext highlighter-rouge">map()</code>(Transforming an array, Replacing items in an array).</li> </ul> <h4 id="updating-objects-inside-arrays-nested-state">Updating objects inside arrays (nested state)</h4> <p>You don’t have to deep copy all the objects for every update, but you need to create copies from the point where you want to update, and all the way up to the top level. Using <code class="language-plaintext highlighter-rouge">map</code> and spread <code class="language-plaintext highlighter-rouge">...</code> can make it.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">initialList</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Big Bellies</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lunar Landscape</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Terracotta Army</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
<span class="p">];</span>

<span class="kd">const</span> <span class="p">[</span><span class="nx">myList</span><span class="p">,</span> <span class="nx">setMyList</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialList</span><span class="p">);</span>
<span class="nf">setMyList</span><span class="p">(</span><span class="nx">myList</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">artwork</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">artwork</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">artworkId</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create a *new* object with changes</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">artwork</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="nx">nextSeen</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// No changes</span>
    <span class="k">return</span> <span class="nx">artwork</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}));</span>
</code></pre></div></div> <h3 id="why-key-is-matter">Why <code class="language-plaintext highlighter-rouge">key</code> is matter?</h3> <h3 id="why-react-choose-immutable">Why React choose Immutable</h3> <ul> <li>Good for Debugging: If you use console.log and don’t mutate state, your past logs won’t get clobbered by the more recent state changes.</li> <li>Common React optimization strategies rely on skipping work if previous props or state are the same as the next ones.</li> <li>Easy for some implements, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values.</li> <li>Make Implementation simpler. And that is the reason why you can set Object as State.</li> </ul> <blockquote class="block-warning"> <p>Important concept in Immutable: ‘Nested’ Objects are not really nested. Nesting is an inaccurate way to think about how objects behave.</p> </blockquote> <h3 id="do-react-have-component-instance-concept-when-placing-a-component-in-different-place-all-of-them-keep-their-own-states-that-means-react-manage-defferent-instances-of-the-component">Do React have component instance concept? When placing a component in different place, all of them keep their own states. That means React manage defferent instances of the component.</h3> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Oct 15, 2023</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/react"> <i class="fas fa-tag fa-sm"></i> React</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/hook"> <div class="tag"> Hook </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#understand-state-in-react"> # Understand State in React </a> </div> <div class="toc-item"> <a href="#state-rules"> # State Rules </a> </div> <div class="toc-item"> <a href="#usestate-hook"> # useState Hook </a> </div> <div class="toc-item"> <a href="#syntax">     # Syntax </a> </div> <div class="toc-item"> <a href="#how-react-implement-usestate-hook">     # How React implement `useState` Hook </a> </div> <div class="toc-item"> <a href="#how-about-setstate">     # How about `setState` </a> </div> <div class="toc-item"> <a href="#set-state-to-a-function">     # Set State to a function </a> </div> <div class="toc-item"> <a href="#fqa"> # FQA </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>