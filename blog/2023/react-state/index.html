<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>React State system | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2023/react-state/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">React State system</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <p>State is the core concept of React component. Imagine you was asked to write web-apps with JavaScript without React or other framework. Using global variables to manage the whole app states, manage update DOM, that will be your first idea to write robust app. State in React is the similar idea of it.</p> <h2 id="state-rules">State Rules</h2> <ul> <li>Treat all state in React as <strong>immutable</strong>. This help React run very fast.</li> <li>State behaves as a <strong>snapshot</strong>. Setting state does not change the state variable you already have, but instead triggers a re-render.</li> <li>State actually “lives” in React itself outside of your function.</li> <li>When triggering a render, React calls your component, it gives you a snapshot of the state for that particular render.</li> <li>This new snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</li> <li>React will ignore your update if the next state is equal to the previous state, as determined by an <code class="language-plaintext highlighter-rouge">Object.is</code> comparison.</li> <li>You can store information from previous renders, but need to use condition, and also, the logic is hard to read. try to avoid.</li> <li>When you call the <code class="language-plaintext highlighter-rouge">set</code> function of useState hook during render, React will re-render that component immediately after your component exits with a <code class="language-plaintext highlighter-rouge">return</code> statement, and before rendering the children.</li> <li>Unlike props, state is fully private to the component declaring it. If you render the same component twice, each copy will have completely isolated state!</li> <li>React batches state updates, it will queue all set functions and execute all set functions one by one before re-render.</li> <li>React will reset all state of a component when it’s <code class="language-plaintext highlighter-rouge">key</code> prop change! That means the <code class="language-plaintext highlighter-rouge">initializer function</code> of <code class="language-plaintext highlighter-rouge">setState function</code> will run again.</li> <li>We usually use <code class="language-plaintext highlighter-rouge">Array.map()</code> to list content component in React. This require mark <code class="language-plaintext highlighter-rouge">key</code> prop for every list component. When causing re-render, <code class="language-plaintext highlighter-rouge">Array.map()</code> will re-run and recaculate all the list components. In this situation, the List component still can use useState() to store it’s states! It just like other components, in re-render, React won’t remove it and create a new component, React still keep state snapshot of the list component.</li> </ul> <h3 id="rules-for-structuring-state">Rules for structuring state</h3> <p>When you write a component that holds some state, you’ll have to make choices about how many state variables to use and what the shape of their data should be. There are a few principles that can guide you to make better choices:</p> <ul> <li>Group related state.</li> <li>Avoid contradictions in state.</li> <li>Avoid redundant state. If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.</li> <li>Avoid duplication in state.</li> <li>Avoid deeply nested state. Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.</li> </ul> <h3 id="sharing-state-between-components">Sharing State Between Components</h3> <p>The key point is <strong>Lifting State Up</strong>.</p> <p>For example, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. Usually, you will pass some functions down as well, these let child components change the parents’ state.</p> <h2 id="understand-state-in-react">Understand State in React</h2> <h3 id="state-is-tied-to-a-position-in-the-render-tree">State is tied to a position in the render tree</h3> <p>When you give a component state, you might think the state “lives” inside the component. But the state is actually held inside React. React associates each piece of state it’s holding with the correct component by where that component sits in the render tree.</p> <p>React preserves a component’s state for as long as it’s being rendered at its position in the UI tree. If it gets removed, or a different component gets rendered at the same position, React discards its state. But <strong>Same component at the same position preserves state</strong>, even its CSS style change. It’s the same component at the same position, so from React’s perspective, it’s the same counter.</p> <blockquote class="block-warning"> <p>Remember that it’s the position in the UI tree, NOT in the JSX markup, that matters to React!</p> </blockquote> <h4 id="how-react-think-about-component-position">How React think about component position</h4> <p>As a rule of thumb, if you want to preserve the state between re-renders, the structure of your tree needs to <strong>match up</strong> from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree.</p> <p>But How React think about component structure?</p> <ul> <li>Rendering a component in a way below, React will think <strong>different</strong> structure for each render and destroy <code class="language-plaintext highlighter-rouge">&lt;Counter&gt;</code> states: <div class="language-ts highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">Scoreboard</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">isPlayerA</span><span class="p">,</span> <span class="nx">setIsPlayerA</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="k">return </span><span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="p">{</span><span class="nx">isPlayerA</span> <span class="o">&amp;&amp;</span>
      <span class="o">&lt;</span><span class="nx">Counter</span> <span class="nx">person</span><span class="o">=</span><span class="dl">"</span><span class="s2">Taylor</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="p">}</span>
    <span class="p">{</span><span class="o">!</span><span class="nx">isPlayerA</span> <span class="o">&amp;&amp;</span>
      <span class="o">&lt;</span><span class="nx">Counter</span> <span class="nx">person</span><span class="o">=</span><span class="dl">"</span><span class="s2">Sarah</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="p">}</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setIsPlayerA</span><span class="p">(</span><span class="o">!</span><span class="nx">isPlayerA</span><span class="p">);</span>
    <span class="p">}}</span><span class="o">&gt;</span>
      <span class="nx">Next</span> <span class="nx">player</span><span class="o">!</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>But if you rendering the way below, React will think it is <strong>same</strong> structure and keep states: <div class="language-ts highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">Scoreboard</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">isPlayerA</span><span class="p">,</span> <span class="nx">setIsPlayerA</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="k">return </span><span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="p">{</span><span class="nx">isPlayerA</span> <span class="p">?</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Counter</span> <span class="nx">key</span><span class="o">=</span><span class="dl">"</span><span class="s2">Taylor</span><span class="dl">"</span> <span class="nx">person</span><span class="o">=</span><span class="dl">"</span><span class="s2">Taylor</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="p">)</span> <span class="p">:</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Counter</span> <span class="nx">key</span><span class="o">=</span><span class="dl">"</span><span class="s2">Sarah</span><span class="dl">"</span> <span class="nx">person</span><span class="o">=</span><span class="dl">"</span><span class="s2">Sarah</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="p">)}</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setIsPlayerA</span><span class="p">(</span><span class="o">!</span><span class="nx">isPlayerA</span><span class="p">);</span>
    <span class="p">}}</span><span class="o">&gt;</span>
      <span class="nx">Next</span> <span class="nx">player</span><span class="o">!</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ul> <blockquote class="block-warning"> <p>React will take <code class="language-plaintext highlighter-rouge">{null}</code> as one child! it will take a position in the render tree.</p> </blockquote> <p>So React will keep <code class="language-plaintext highlighter-rouge">&lt;Form /&gt;</code> state for every render, because it is in same position all the time.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="p">[</span><span class="nx">showHint</span><span class="p">,</span> <span class="nx">setShowHint</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">showHint</span><span class="p">?(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Hint</span><span class="p">:</span> <span class="nx">Your</span> <span class="nx">favorite</span> <span class="nx">city</span><span class="p">?</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Form</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">):(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="kc">null</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">Form</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
</code></pre></div></div> <h4 id="key-and-position">key and position</h4> <p>You can Reset component state with a <code class="language-plaintext highlighter-rouge">key</code>. Keys aren’t just for lists! You can use keys to make React distinguish between any components.</p> <blockquote class="block-warning"> <p>Specifying a key tells React to use the key itself as part of the position, instead of their order within the parent. Remember that keys are not globally unique. They only specify the position within the parent.</p> </blockquote> <p>Resetting state with a key is particularly useful when dealing with <strong>forms</strong>. For example, Contact Manage App, Chat App, Using person information as key to manage form will be a good idea.</p> <p>Also, use key prop to Presever state even the order of components change.</p> <h4 id="practice-hint">Practice Hint</h4> <ul> <li> <strong>Don’t nest</strong> component function definitions. Because every render will create new component, and React will reset it’s states.</li> <li> <strong>How to Reset state at the same position</strong>. By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component’s state. <ul> <li>Rendering “different” position of the component.</li> <li>Rendering with a <code class="language-plaintext highlighter-rouge">key</code>.</li> </ul> </li> <li> <strong>How to Preserve state for removed components</strong> <ul> <li>Don’t remove it, hide the component with CSS.</li> <li>Lift the state up.</li> <li>Use a different source in addition to React state.</li> </ul> </li> <li>How to Preserve state when change order of a list of components. Using <code class="language-plaintext highlighter-rouge">key</code> prop!</li> </ul> <p>Maybe you can refer this as React instance concept.</p> <h3 id="state-vs-ref">State vs Ref</h3> <p>State and Ref are comparable. React use them for different purpose.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">ref</code> could point to anything: a string, an object, or even a function.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">refs</code> both are live outside of your component.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> and <code class="language-plaintext highlighter-rouge">refs</code> both are retained by React between re-renders.</li> <li>Mutating <code class="language-plaintext highlighter-rouge">state</code> cause re-render. Mutating <code class="language-plaintext highlighter-rouge">ref</code> won’t.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> works as snapshot for each render, You can’t get latest state from an asynchronous operation; But <code class="language-plaintext highlighter-rouge">ref</code> won’t be affected by render, you can read the latest ref anytime.</li> <li> <code class="language-plaintext highlighter-rouge">state</code> is ”Immutable” — you must use the state setting function to modify state variables to queue a re-render; <code class="language-plaintext highlighter-rouge">ref</code> is mutable, it is a <strong>plain</strong> JavaScript object that you can read and modify.</li> <li>You shouldn’t read (or write) the <code class="language-plaintext highlighter-rouge">ref.current</code> value during rendering. But You can read <code class="language-plaintext highlighter-rouge">state</code> any time.</li> </ul> <h3 id="state-behaves-as-snapshot">State behaves as snapshot</h3> <p>States are a component’s memory. State actually “lives” in React itself (as if on a shelf!) outside of your function. When triggering a render, React calls your component, it gives you a snapshot of the state for that particular render.</p> <p>This snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!</p> <p>But how to understand this component:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">setCounter</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">setCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">delay</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
    <span class="nf">setCounter</span><span class="p">(</span><span class="nx">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span>
        <span class="nx">counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">counter</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="nx">add</span> <span class="nx">it</span>     
      <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nf">delay</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// It will display "counter: -1" when click the button.</span>
</code></pre></div></div> <p>It still make sense like this: When you click, cause a re-render, React return a second snapshot: <code class="language-plaintext highlighter-rouge">counter: 1</code> for the new render; After 3 seconds, <code class="language-plaintext highlighter-rouge">setCounter(counter - 1);</code> executed and trigger a new render as well but this code is executed based on the old snapshot: <code class="language-plaintext highlighter-rouge">counter: 0</code>. It still trigger a render and create a new snapshot: <code class="language-plaintext highlighter-rouge">counter: -1</code>; In this case, React just manage one memory for this component because it is in the same place.</p> <blockquote class="block-warning"> <p>So, Don’t read the latest state from an asynchronous operation, like a timeout. It is confused!</p> </blockquote> <h3 id="how-react-update-states">How React update states</h3> <ul> <li>If you have many states need to be updated. React <strong>batches</strong> state updates. That means State updates are queued. This lets you update multiple state variables without triggering too many re-renders.</li> <li>React waits until all code in the event handlers has run before processing your state updates.</li> </ul> <p>Understand <strong>queue</strong> the state udpate:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">setNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">number</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nf">setNumber</span><span class="p">(</span><span class="nx">number</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
        <span class="nf">setNumber</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}}</span><span class="o">&gt;</span><span class="nx">You</span> <span class="nx">will</span> <span class="kd">get</span> <span class="mi">6</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nf">setNumber</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">setNumber</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">setNumber</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}}</span><span class="o">&gt;</span><span class="nx">You</span> <span class="nx">will</span> <span class="kd">get</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="flushsync">flushSync()</h4> <p>you can force React to update (or call ‘flush’) the DOM <strong>synchronously</strong> according to state update. To do this, import flushSync from react-dom and wrap the state update into a <code class="language-plaintext highlighter-rouge">flushSync</code> call:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">flushSync</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTodos</span><span class="p">([</span> <span class="p">...</span><span class="nx">todos</span><span class="p">,</span> <span class="nx">newTodo</span><span class="p">]);</span>
<span class="p">});</span>
<span class="nx">listRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">lastChild</span><span class="p">.</span><span class="nf">scrollIntoView</span><span class="p">();</span>
</code></pre></div></div> <h2 id="usestate-hook">useState Hook</h2> <h3 id="syntax">Syntax</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
</code></pre></div></div> <p>useState returns an array with exactly two items:</p> <ol> <li>The current state of this state variable, initially set to the initial state you provided.</li> <li>The set function that lets you change it to any other value in response to interaction.</li> </ol> <p>Important to Know:</p> <ol> <li>Calling the set function does not change the current state in the already executing code.</li> <li>State is considered read-only, When state is objects or arrays, you should replace it rather than mutate your existing objects.</li> <li>About the initial state, React saves it once and ignores it on the next renders. So don’t do this: <code class="language-plaintext highlighter-rouge">const [todos, setTodos] = useState(createInitialTodos());</code>, because React run this function every render and means nothing. But you can do this: <code class="language-plaintext highlighter-rouge">const [todos, setTodos] = useState(createInitialTodos);</code>.</li> </ol> <h3 id="how-react-implement-usestate-hook">How React implement <code class="language-plaintext highlighter-rouge">useState</code> Hook</h3> <p>It is helpful to know How <code class="language-plaintext highlighter-rouge">useState</code> works inside React. Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to 0 before rendering. Each time you call useState, React gives you the next state pair and increments the index. Hooks rely on a stable call <strong>order</strong> on every render of the same component. Roughly like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">componentHooks</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">currentHookIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">componentHooks</span><span class="p">[</span><span class="nx">currentHookIndex</span><span class="p">];</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This is not the first render,</span>
    <span class="c1">// so the state pair already exists.</span>
    <span class="c1">// Return it and prepare for next Hook call.</span>
    <span class="nx">currentHookIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">pair</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This is the first time we're rendering,</span>
  <span class="c1">// so create a state pair and store it.</span>
  <span class="nx">pair</span> <span class="o">=</span> <span class="p">[</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">setState</span><span class="p">];</span>

  <span class="kd">function</span> <span class="nf">setState</span><span class="p">(</span><span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// When the user requests a state change,</span>
    <span class="c1">// put the new value into the pair.</span>
    <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextState</span><span class="p">;</span>
    <span class="nf">updateDOM</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Store the pair for future renders</span>
  <span class="c1">// and prepare for the next Hook call.</span>
  <span class="nx">componentHooks</span><span class="p">[</span><span class="nx">currentHookIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pair</span><span class="p">;</span>
  <span class="nx">currentHookIndex</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">pair</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="how-about-set-function-in-usestate">How about <code class="language-plaintext highlighter-rouge">set function</code> in useState</h3> <p>The set function returned by <code class="language-plaintext highlighter-rouge">useState</code> lets you update the state to a different value and trigger a re-render.</p> <p>You can pass the next <strong>state value</strong> directly, OR a <strong>‘updater function’</strong> that calculates it from the previous state. Because <strong>React batches state updates</strong>, it will queue all these set functions and execute all these set functions one by one before re-render. React will treat updater function differently from direct value (<code class="language-plaintext highlighter-rouge">baseState</code> is current value; <code class="language-plaintext highlighter-rouge">queue</code> is setfunctions array) :</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nf">getFinalState</span><span class="p">(</span><span class="nx">baseState</span><span class="p">,</span> <span class="nx">queue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">finalState</span> <span class="o">=</span> <span class="nx">baseState</span><span class="p">;</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">updater</span> <span class="k">of</span> <span class="nx">queue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">updater</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Apply the updater function.</span>
      <span class="nx">finalState</span> <span class="o">=</span> <span class="nf">updater</span><span class="p">(</span><span class="nx">finalState</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Replace the next state.</span>
      <span class="nx">finalState</span> <span class="o">=</span> <span class="nx">updater</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">finalState</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="some-rules-for-usestate-hook">Some Rules for <code class="language-plaintext highlighter-rouge">useState</code> Hook</h3> <ul> <li>The <strong>order</strong> is matter! React execute the setState functions in exact order.</li> <li>The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call. It is Async.</li> <li>If the new value you provide is identical to the current state, as determined by an <code class="language-plaintext highlighter-rouge">Object.is</code> comparison, React will skip re-rendering the component and its children.</li> <li>Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders.</li> <li>In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production.</li> <li>The initialer of useState will just run at the first time.</li> <li>When you call the <code class="language-plaintext highlighter-rouge">set function</code> of useState hook during render, React will re-render that component immediately after your component exits with a <code class="language-plaintext highlighter-rouge">return</code> statement, and before rendering the childre.</li> </ul> <h3 id="set-state-to-a-function">Set State to a function</h3> <p>Don’t do this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">setFn</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">someFunction</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setFn</span><span class="p">(</span><span class="nx">someOtherFunction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put <code class="language-plaintext highlighter-rouge">()=&gt;</code> before them in both cases. Then React will store the functions you pass.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">setFn</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">someFunction</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">handleClick</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setFn</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">someOtherFunction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>The different between <code class="language-plaintext highlighter-rouge">someFunction</code> and <code class="language-plaintext highlighter-rouge">()=&gt;someFunction</code> is that, executing latter will return former.</p> </blockquote> <h3 id="updating-objects-in-state">Updating Objects in State</h3> <blockquote> <h5 id="why-changing-object-state-directly-wont-work">Why changing object state directly won’t work?</h5> <p>Becuase React use <code class="language-plaintext highlighter-rouge">Object.is</code> to comparation, which decide whether to cause re-render.</p> </blockquote> <p>So, the Rule is that You should Treat state as read-only.</p> <ul> <li>Copying objects with the <strong>spread syntax</strong>.</li> <li>Updating a nested object! For example, update ‘city’ to ‘NewYork’: <div class="language-js highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">person</span><span class="p">,</span> <span class="nx">setPerson</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">({</span>
<span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Niki de Saint Phalle</span><span class="dl">'</span><span class="p">,</span>
<span class="na">artwork</span><span class="p">:</span> <span class="p">{</span>
  <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Blue Nana</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">city</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hamburg</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">image</span><span class="p">:</span> <span class="dl">'</span><span class="s1">https://i.imgur.com/Sd1AgUOm.jpg</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
<span class="p">});</span>
</code></pre></div> </div> <p>You can update it like below:</p> <div class="language-js highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">setPerson</span><span class="p">({</span>
<span class="p">...</span><span class="nx">person</span><span class="p">,</span> <span class="c1">// Copy other fields</span>
<span class="na">artwork</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// but replace the artwork</span>
  <span class="p">...</span><span class="nx">person</span><span class="p">.</span><span class="nx">artwork</span><span class="p">,</span> <span class="c1">// with the same one</span>
  <span class="na">city</span><span class="p">:</span> <span class="dl">'</span><span class="s1">NewYork</span><span class="dl">'</span> <span class="c1">// but in NewYork!</span>
<span class="p">}</span>
<span class="p">});</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>Nested Objects are not really nested. “nesting” is an inaccurate way to think about how objects behave. There are just reference which point to another object.</p> </blockquote> <h3 id="updating-arrays-in-state">Updating Arrays in State</h3> <p>You can use Immer plus in! But I prefer do it by Knowing what you are doing. Basic Rule is that you should treat arrays in React state as read-only.</p> <h4 id="prefer-array-methodsreturns-a-new-array">prefer Array methods(returns a new array):</h4> <ul> <li>adding: <code class="language-plaintext highlighter-rouge">concat</code>, <code class="language-plaintext highlighter-rouge">[...arr]</code> </li> <li>inserting: <code class="language-plaintext highlighter-rouge">[...arr]</code> together with the <code class="language-plaintext highlighter-rouge">slice()</code> method: <div class="language-js highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">nextArtists</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">// Items before the insertion point:</span>
    <span class="p">...</span><span class="nx">artists</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">insertAt</span><span class="p">),</span>
    <span class="c1">// New item:</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">nextId</span><span class="o">++</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="nx">name</span> <span class="p">},</span>
    <span class="c1">// Items after the insertion point:</span>
    <span class="p">...</span><span class="nx">artists</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">insertAt</span><span class="p">)</span>
  <span class="p">];</span>
</code></pre></div> </div> </li> <li>removing: <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">slice</code> </li> <li>Transforming (change some or all items of the array): <code class="language-plaintext highlighter-rouge">map</code> </li> <li>replacing: <code class="language-plaintext highlighter-rouge">map</code> </li> <li>reversing or sorting: <strong>copy the array first</strong> <div class="language-js highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">nextList</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">list</span><span class="p">];</span>
<span class="nx">nextList</span><span class="p">.</span><span class="nf">reverse</span><span class="p">();</span>
</code></pre></div> </div> </li> <li>When updating <strong>nested</strong> state, you need to create copies from the point where you want to update, and all the way up to the top level. You don’t have to deep copy all the objects for every update, but you need to create copies from the point where you want to update, and all the way up to the top level. Using <code class="language-plaintext highlighter-rouge">map</code> and spread <code class="language-plaintext highlighter-rouge">...</code> can make it. <div class="language-js highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">initialList</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Big Bellies</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
<span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Lunar Landscape</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
<span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Terracotta Army</span><span class="dl">'</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">myList</span><span class="p">,</span> <span class="nx">setMyList</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialList</span><span class="p">);</span>
<span class="nf">setMyList</span><span class="p">(</span><span class="nx">myList</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">artwork</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="k">if </span><span class="p">(</span><span class="nx">artwork</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">artworkId</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Create a *new* object with changes</span>
  <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">artwork</span><span class="p">,</span> <span class="na">seen</span><span class="p">:</span> <span class="nx">nextSeen</span> <span class="p">};</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// No changes</span>
  <span class="k">return</span> <span class="nx">artwork</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}));</span>
</code></pre></div> </div> </li> </ul> <h4 id="avoid-mutates-the-array">Avoid (mutates the array):</h4> <ul> <li>adding: <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">unshift</code> </li> <li>removing: <code class="language-plaintext highlighter-rouge">pop</code>, <code class="language-plaintext highlighter-rouge">shift</code>, <code class="language-plaintext highlighter-rouge">splice</code> </li> <li>replacing: <code class="language-plaintext highlighter-rouge">splice</code>, <code class="language-plaintext highlighter-rouge">arr[i] = ... assignment</code> </li> <li>sorting: <code class="language-plaintext highlighter-rouge">reverse</code>, <code class="language-plaintext highlighter-rouge">sort</code> </li> </ul> <h2 id="usereducer-hook">useReducer Hook</h2> <p><code class="language-plaintext highlighter-rouge">useReducer</code> is build on top of <code class="language-plaintext highlighter-rouge">useState</code> technicially, and it provide a <strong>framework</strong> to manage state. This framework is more descriptive of the user’s intent, and make code easier to understand.</p> <p>The basic idea of this framework is that, concluding user’s intentions into objects, called action objects, which will be dispatched to a <code class="language-plaintext highlighter-rouge">reducer</code> function. <code class="language-plaintext highlighter-rouge">reducer</code> function is a pure function which consolidate a component’s state update logic and return the next <code class="language-plaintext highlighter-rouge">state</code>.</p> <p><code class="language-plaintext highlighter-rouge">useReducer</code> is build on top of <code class="language-plaintext highlighter-rouge">useState</code>. It behavior exactly like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nf">useReducer</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nf">dispatch</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">setState</span><span class="p">((</span><span class="nx">s</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">reducer</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">action</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <p>You can declare <code class="language-plaintext highlighter-rouge">reducer</code> function outside of your component. This decreases the indentation level and can make your code easier to read.</p> <h3 id="migrating-from-usestate-to-usereducer">Migrating from <code class="language-plaintext highlighter-rouge">useState</code> to <code class="language-plaintext highlighter-rouge">useReducer</code> </h3> <ol> <li>Move from setting state to dispatching actions.</li> <li>Write a reducer function.</li> <li>Use the reducer from your component.</li> </ol> <h4 id="move-from-setting-state-to-dispatching-actions">Move from setting state to dispatching actions</h4> <p>Managing state with reducers is slightly different from directly setting state. Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers.</p> <p>What is dispatching actions?</p> <p>Dispatching actions are normal objects. It is common to give action object a string type that describes what happened, and pass any additional information in other fields.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">handleAddTask</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">dispatch</span><span class="p">({</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">added</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">id</span><span class="p">:</span> <span class="nx">nextId</span><span class="o">++</span><span class="p">,</span>
    <span class="na">text</span><span class="p">:</span> <span class="nx">text</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="write-a-reducer-function">Write a reducer function</h4> <p>To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a “reducer”.</p> <p>A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">yourReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// return next state for React to set</span>
<span class="p">}</span>
</code></pre></div></div> <p>React will set the state to what you return from the reducer.</p> <blockquote> <p>Reducer concept is come from the reducer in <code class="language-plaintext highlighter-rouge">Array.reduce()</code>. You could even use the <code class="language-plaintext highlighter-rouge">reduce()</code> method with an <code class="language-plaintext highlighter-rouge">initialState</code> and <strong>an array of actions</strong> to calculate the final state by passing your reducer function to it.</p> </blockquote> <h4 id="use-usereducer">Use <code class="language-plaintext highlighter-rouge">useReducer</code> </h4> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">tasks</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useReducer</span><span class="p">(</span><span class="nx">tasksReducer</span><span class="p">,</span> <span class="nx">initialTasks</span><span class="p">);</span>
</code></pre></div></div> <p>The useReducer Hook takes two arguments:</p> <ul> <li>A reducer function</li> <li>An initial state</li> </ul> <p>And it returns:</p> <ul> <li>A stateful value</li> <li>A dispatch function (to “dispatch” user actions to the reducer)</li> </ul> <p>Now every time you pass an <code class="language-plaintext highlighter-rouge">action object</code> to <code class="language-plaintext highlighter-rouge">dispatch</code> function, React can update your state.</p> <h3 id="comparing-usestate-and-usereducer">Comparing <code class="language-plaintext highlighter-rouge">useState</code> and <code class="language-plaintext highlighter-rouge">useReducer</code> </h3> <ul> <li> <strong>Code size</strong>: Generally, with useState you have to write less code upfront. With useReducer, you have to write both a reducer function and dispatch actions. However, useReducer can help cut down on the code if many event handlers modify state in a similar way.</li> <li> <strong>Readability</strong>: useState is very easy to read when the state updates are simple. When they get more complex, they can bloat your component’s code and make it difficult to scan. In this case, useReducer lets you cleanly separate the how of update logic from the what happened of event handlers.</li> <li> <strong>Debugging</strong>: When you have a bug with useState, it can be difficult to tell where the state was set incorrectly, and why. With useReducer, you can add a console log into your reducer to see every state update, and why it happened (due to which action). If each action is correct, you’ll know that the mistake is in the reducer logic itself. However, you have to step through more code than with useState.</li> <li> <strong>Testing</strong>: A reducer is a pure function that doesn’t depend on your component. This means that you can export and test it separately in isolation. While generally it’s best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.</li> <li> <strong>Personal preference</strong>: Some people like reducers, others don’t. That’s okay. It’s a matter of preference. You can always convert between useState and useReducer back and forth: they are equivalent!</li> </ul> <h3 id="writing-reducers-well">Writing reducers well</h3> <p>Keep these two tips in mind when writing reducers:</p> <ul> <li> <strong>Reducers must be pure</strong>. Similar to state updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducers must be pure—same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should update objects and arrays without mutations.</li> <li> <strong>Each action describes a single user interaction, even if that leads to multiple changes in the data</strong>. For example, if a user presses “Reset” on a form with five fields managed by a reducer, it makes more sense to dispatch one reset_form action rather than five separate set_field actions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!</li> </ul> <h2 id="fqa">FQA</h2> <h3 id="why-react-choose-immutable">Why React choose Immutable</h3> <ul> <li>Good for Debugging: If you use console.log and don’t mutate state, your past logs won’t get clobbered by the more recent state changes.</li> <li>Common React optimization strategies rely on skipping work if previous props or state are the same as the next ones.</li> <li>Easy for some implements, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values.</li> <li>Make Implementation simpler. And that is the reason why you can set Object as State.</li> </ul> <blockquote class="block-warning"> <p>Important concept in Immutable: ‘Nested’ Objects are not really nested. Nesting is an inaccurate way to think about how objects behave.</p> </blockquote> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Oct 15, 2023</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/react"> <i class="fas fa-tag fa-sm"></i> React</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/hook"> <div class="tag"> Hook </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#state-rules"> # State Rules </a> </div> <div class="toc-item"> <a href="#rules-for-structuring-state">     # Rules for structuring state </a> </div> <div class="toc-item"> <a href="#sharing-state-between-components">     # Sharing State Between Components </a> </div> <div class="toc-item"> <a href="#understand-state-in-react"> # Understand State in React </a> </div> <div class="toc-item"> <a href="#state-is-tied-to-a-position-in-the-render-tree">     # State is tied to a position in the render tree </a> </div> <div class="toc-item"> <a href="#state-vs-ref">     # State vs Ref </a> </div> <div class="toc-item"> <a href="#state-behaves-as-snapshot">     # State behaves as snapshot </a> </div> <div class="toc-item"> <a href="#how-react-update-states">     # How React update states </a> </div> <div class="toc-item"> <a href="#usestate-hook"> # useState Hook </a> </div> <div class="toc-item"> <a href="#syntax">     # Syntax </a> </div> <div class="toc-item"> <a href="#how-react-implement-usestate-hook">     # How React implement `useState` Hook </a> </div> <div class="toc-item"> <a href="#how-about-setstate">     # How about `setState` </a> </div> <div class="toc-item"> <a href="#set-state-to-a-function">     # Set State to a function </a> </div> <div class="toc-item"> <a href="#updating-objects-in-state">     # Updating Objects in State </a> </div> <div class="toc-item"> <a href="#updating-arrays-in-state">     # Updating Arrays in State </a> </div> <div class="toc-item"> <a href="#usereducer-hook"> # useReducer Hook </a> </div> <div class="toc-item"> <a href="#migrating-from-usestate-to-usereducer">     # Migrating from `useState` to `useReducer` </a> </div> <div class="toc-item"> <a href="#comparing-usestate-and-usereducer">     # Comparing `useState` and `useReducer` </a> </div> <div class="toc-item"> <a href="#writing-reducers-well">     # Writing reducers well </a> </div> <div class="toc-item"> <a href="#fqa"> # FQA </a> </div> <div class="toc-item"> <a href="#why-react-choose-immutable">     # Why React choose Immutable </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>