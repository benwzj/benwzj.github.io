<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Use Memoization in React | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2023/memo-react/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <style>html{scroll-behavior:smooth}</style> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Use Memoization in React</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <p>The main thing that React does is keep our UI in sync with our application state. The tool that it uses to do this is called a “re-render”.</p> <p>Each re-render is a snapshot of what the application’s UI should look like at a given moment in time, based on the current application state. You can use Memoization function to memoize these snapshot for optimization.</p> <h2 id="api-reactmemo">API <code class="language-plaintext highlighter-rouge">React.memo()</code> </h2> <p>React normally re-renders a component whenever its parent re-renders. With <code class="language-plaintext highlighter-rouge">React.memo()</code>, you can create a component that React will not re-render when its parent re-renders so long as its new <strong>props</strong> are the same as the old props. Such a component is said to be memoized.</p> <h3 id="how-to-check-if-a-compnent-is-re-rendered">How to check if a compnent is re-rendered</h3> <p>Re-render a component, means React execute that component function to calculate the output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">count</span><span class="o">++</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">component render number: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">count</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div> <p>But the component might be only invoked without rerendering. For example, you <code class="language-plaintext highlighter-rouge">setState()</code> to the same value as previous one, React will run the component function, but without rendering the children or firing effects.</p> <p>So the better way is to make a <code class="language-plaintext highlighter-rouge">useEffect</code> hook without a dependency array, this will make it run after each component render.</p> <p>How to display render count in react component? You can’t use State, but you can use <strong>Ref</strong>!!</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="nx">props</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">renderCounter</span>  <span class="o">=</span> <span class="nf">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nf">useEffect </span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
      <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="na">Renders</span><span class="p">:</span> <span class="p">{</span><span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span><span class="p">},</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">};</span>
</code></pre></div></div> <h3 id="how-to-use">How to Use</h3> <p><code class="language-plaintext highlighter-rouge">const MemoizedComponent = memo(SomeComponent, arePropsEqual?)</code></p> <p>Wrap a component in <code class="language-plaintext highlighter-rouge">memo</code> to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.</p> <p>To memoize a component, wrap it in <code class="language-plaintext highlighter-rouge">memo</code> and use the value that it returns in place of your original component:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">memo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">SomeComponent</span> <span class="o">=</span> <span class="nf">memo</span><span class="p">(</span><span class="kd">function</span> <span class="nf">SomeComponent</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div> <h3 id="usage">Usage</h3> <ul> <li>Skipping re-rendering when props are unchanged</li> <li>Updating a memoized component using state</li> <li>Updating a memoized component using a context</li> <li>Minimizing props changes</li> <li>Specifying a custom comparison function</li> </ul> <h2 id="hook-usememo">Hook <code class="language-plaintext highlighter-rouge">useMemo</code> </h2> <p><code class="language-plaintext highlighter-rouge">useMemo</code> is a React Hook that lets you cache the result of a calculation between re-renders. You should only rely on <code class="language-plaintext highlighter-rouge">useMemo</code> as a <strong>performance optimization</strong>. Caching return values like this is known as <strong>memoization</strong>, which is why this Hook is called <code class="language-plaintext highlighter-rouge">useMemo</code>.</p> <blockquote> <p>Main purpose of <code class="language-plaintext highlighter-rouge">useMemo</code> is Skipping expensive recalculations.</p> </blockquote> <h3 id="optimizing-with-usememo-is-only-valuable-in-a-few-cases">Optimizing with useMemo is only valuable in a few cases:</h3> <ul> <li>The calculation you’re putting in useMemo is noticeably slow, and its dependencies rarely change.</li> <li>You pass it as a prop to a component wrapped in <a href="https://react.dev/reference/react/memo" rel="external nofollow noopener" target="_blank">memo</a> API. You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only when dependencies aren’t the same.</li> <li>The value you’re passing is later used as a dependency of some Hook. For example, maybe another useMemo calculation value depends on it. Or maybe you are depending on this value from useEffect.</li> </ul> <h3 id="how-to-tell-if-a-calculation-is-expensive">How to tell if a calculation is expensive?</h3> <p>You can add a console log to measure the time spent in a piece of code:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">time</span><span class="p">(</span><span class="dl">'</span><span class="s1">filter array</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">visibleTodos</span> <span class="o">=</span> <span class="nf">getFilteredTodos</span><span class="p">(</span><span class="nx">todos</span><span class="p">,</span> <span class="nx">filter</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">timeEnd</span><span class="p">(</span><span class="dl">'</span><span class="s1">filter array</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation.</p> <h3 id="using-usememo">Using useMemo</h3> <p>Syntax: <code class="language-plaintext highlighter-rouge">const cachedValue = useMemo(calculateValue, dependencies)</code> Reture:</p> <ul> <li>On the initial render, useMemo returns the result of calling calculateValue with no arguments.</li> <li>During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.</li> </ul> <p>Example:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useMemo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">TodoList</span><span class="p">({</span> <span class="nx">todos</span><span class="p">,</span> <span class="nx">tab</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">visibleTodos</span> <span class="o">=</span> <span class="nf">useMemo</span><span class="p">(</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">filterTodos</span><span class="p">(</span><span class="nx">todos</span><span class="p">,</span> <span class="nx">tab</span><span class="p">),</span>
    <span class="p">[</span><span class="nx">todos</span><span class="p">,</span> <span class="nx">tab</span><span class="p">]</span>
  <span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="hook-usecallback">Hook <code class="language-plaintext highlighter-rouge">useCallback</code> </h2> <p>Returns a memoized callback.</p> <p><code class="language-plaintext highlighter-rouge">useCallback()</code> often is used in conjunction with <code class="language-plaintext highlighter-rouge">useEffect()</code> because it allows you to prevent the re-creation of a function. For this, it’s important to understand that functions are just objects in JavaScript.</p> <p>In a functional component, any function you define inside of it is re-created whenever the component rebuilds. Normally it is no problem, that innerFunction re-created for every render cycle. But it become a problem if the innerFunction become a dependency of <code class="language-plaintext highlighter-rouge">useEffect()</code>. If innerFunction cause component rebuild, then it will infinite loop.<br> Use <code class="language-plaintext highlighter-rouge">useCallback()</code> can prevent that happen.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">useCallback(fn, deps)</code> is equivalent to <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; fn, deps)</code>.</li> <li> <code class="language-plaintext highlighter-rouge">useCallback</code> will return a memoized version of the callback that only changes if one of the dependencies has changed.</li> <li>This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders .</li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Nov 19, 2023</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/react"> <i class="fas fa-tag fa-sm"></i> React</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/react"> <div class="tag"> React </div> </a> <a href="/blog/tag/hook"> <div class="tag"> Hook </div> </a> <a href="/blog/tag/rendering"> <div class="tag"> Rendering </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#api-react-memo"> # API `React.memo()` </a> </div> <div class="toc-item"> <a href="#hook-usememo"> # Hook `useMemo` </a> </div> <div class="toc-item"> <a href="#hook-usecallback"> # Hook `useCallback` </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>