<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Git Practice | BEN WEN</title> <meta name="author" content="Ben Wen"> <meta name="description" content="A website to show the world of Ben Wen "> <meta name="keywords" content="jekyll, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/mdb.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link defer rel="stylesheet" href="/assets/css/bootstrap-table.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/all.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" href="/assets/css/academicons.min.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/github.css?d41d8cd98f00b204e9800998ecf8427e" media="" id="highlight_theme_light"> <link rel="icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://benwzj.github.io/blog/2021/git-practice/"> <link rel="stylesheet" href="/assets/css/native.css?d41d8cd98f00b204e9800998ecf8427e" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">BEN WEN</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/about/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://github.com/benwzj" rel="external nofollow noopener" target="_blank"> GitHub <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" style="width:1rem;height:1rem;fill:currentColor"> <g data-name="Layer 2"><g data-name="external-link"> <rect width="24" height="24" opacity="0"></rect> <path d="M20 11a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h6a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6a1 1 0 0 0-1-1z"></path> <path d="M16 5h1.58l-6.29 6.28a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L19 6.42V8a1 1 0 0 0 1 1 1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4a1 1 0 0 0 0 2z"></path> </g></g> </svg> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="post col-sm-9"> <h1 class="post-title">Git Practice</h1> <br> <br> <article class="post-content"> <div id="markdown-content"> <p>Git support Parallel Development. Parallel Development means you can create branch.</p> <figure> <picture> <img src="/assets/img/git-parallel.png" class="img-fluid rounded z-depth-1" width="60%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="basic-git-operations">Basic git Operations</h2> <ul> <li>connect your local repository to your remote repository: <code class="language-plaintext highlighter-rouge">git remote add origin https://github.com/benwzj/animationsApp.git</code> </li> <li>push the file to remote repository: <code class="language-plaintext highlighter-rouge">git push origin master</code> </li> <li>create a branch named my_branch: <code class="language-plaintext highlighter-rouge">git branch my_branch</code> </li> <li>checkout my_branch, then you switch to my_branch. What you add, commit will be in my_branch: <code class="language-plaintext highlighter-rouge">git checkout my_branch</code> </li> <li>add file to my_branch, this command just add file to staging area: <code class="language-plaintext highlighter-rouge">git add file1.txt</code> </li> <li>add all untracked files to my_branch: <code class="language-plaintext highlighter-rouge">git add -A</code> </li> <li>adds all modified and new (untracked) files in the current directory and all subdirectories to the staging area (a.k.a. the index), thus preparing them to be included in the next git commit . <code class="language-plaintext highlighter-rouge">git add .</code> </li> <li>remove a file form staging area: <code class="language-plaintext highlighter-rouge">git reset file1.txt</code> </li> <li> <p>remove all staging file: <code class="language-plaintext highlighter-rouge">git reset</code></p> </li> <li>commit file to repository: <code class="language-plaintext highlighter-rouge">git commit -m “some information”</code> </li> <li>merge my_branch to master: <code class="language-plaintext highlighter-rouge">git checkout master</code> <code class="language-plaintext highlighter-rouge">git merge my_branch</code> </li> <li>Now, you have two branch in you local repository: master and my_branch. If you want to push them to remote repository, then: <code class="language-plaintext highlighter-rouge">git push origin master</code> or <code class="language-plaintext highlighter-rouge">git push origin my_branch</code> </li> <li>check log what you have done: <code class="language-plaintext highlighter-rouge">git log</code> Every push have a hash key, Unique hash key.</li> <li>if you company have already a remote repo, you can clone that by: <code class="language-plaintext highlighter-rouge">git clone &lt;url&gt; &lt;where to clone&gt;</code> </li> <li>show remote repo information: <code class="language-plaintext highlighter-rouge">git remote -v</code> </li> <li>before you push you repo to remote, should pull remote repo to local first: <code class="language-plaintext highlighter-rouge">git pull origin master</code> then <code class="language-plaintext highlighter-rouge">git push origin master</code> </li> <li>list all branch in repository: <code class="language-plaintext highlighter-rouge">git branch</code> </li> <li>list all branch including remote repository: <code class="language-plaintext highlighter-rouge">git branch -a</code> </li> <li>create my_branch: <code class="language-plaintext highlighter-rouge">git branch my_branch</code> </li> <li>check out branch, means you are on my_branch now: <code class="language-plaintext highlighter-rouge">git checkout my_branch</code> </li> <li>check which branch merge: <code class="language-plaintext highlighter-rouge">git branch --merged</code> </li> <li>delete branch my_branch: <code class="language-plaintext highlighter-rouge">git branch -d my_branch</code> </li> <li>delete remote branch: <code class="language-plaintext highlighter-rouge">git push origin --delete my_branch</code> </li> </ul> <h3 id="programer-daily-routine">Programer daily routine:</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch day_branch
git checkout day_branch
// Do coding …
git status
git add -A
git commit -m “one day work…”
git push -u origin day_branch
git checkout master
git pull origin master
git merge day_branch
git push origin master
</code></pre></div></div> <h2 id="setting-up-a-repo">Setting up a repo</h2> <h3 id="steps-for-pushing-an-existing-unversioned-project-to-a-git-repository">Steps for Pushing an existing unversioned project to a Git repository.</h3> <ol> <li>Inside project root folder, run <code class="language-plaintext highlighter-rouge">git init</code> creates a .git environment. It will create .git folder and .gitignore file.</li> <li>create repository in Git server, e.g. Github.</li> <li>connect the project to Git server Repository. <code class="language-plaintext highlighter-rouge">git remote add origin git@github.com:benwzj/CodeDeployBlog.git</code> </li> <li>then you can work on it <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>git branch -M main
git add .
git commit -m'initial
git push -u origin main
</code></pre></div> </div> </li> </ol> <h3 id="basic-command-for-repository">Basic Command for Repository</h3> <h4 id="command-git-init">Command <code class="language-plaintext highlighter-rouge">git init</code> </h4> <p>The <code class="language-plaintext highlighter-rouge">git init</code> command creates a new Git repository. It can be used to convert an existing, unversioned project to a Git repository or initialize a new, empty repository. Executing <code class="language-plaintext highlighter-rouge">git init</code> creates a <code class="language-plaintext highlighter-rouge">.git</code> subdirectory in the current working directory, which contains all of the necessary Git metadata for the new repository.</p> <p><code class="language-plaintext highlighter-rouge">git init --bare</code>, Bare repositories is for Central repositories that doesn’t have a working directory <code class="language-plaintext highlighter-rouge">git init template</code>, Templates allow you to initialize a new repository with a predefined .git subdirectory.</p> <h4 id="command-git-clone">Command <code class="language-plaintext highlighter-rouge">git clone</code> </h4> <p>git clone is used to target an existing repository and create a clone, or copy of the target repository. Internally, <code class="language-plaintext highlighter-rouge">git clone</code> first calls <code class="language-plaintext highlighter-rouge">git init</code> to create a new repository. It then copies the data from the existing repository, and checks out a new set of working files.</p> <blockquote> <p>Just do this: <code class="language-plaintext highlighter-rouge">git clone git@github.com:benwzj/CodeDeployBlog.git</code> Everything is done.</p> </blockquote> <h4 id="command-git-config">Command <code class="language-plaintext highlighter-rouge">git config</code> </h4> <p>Executing <code class="language-plaintext highlighter-rouge">git config</code> will modify a configuration text file values on a global or local project level. The most basic use case for <code class="language-plaintext highlighter-rouge">git config</code> is to invoke it with a configuration name, which will display the set value at that name. Configuration names are dot delimited strings composed of a ‘section’ and a ‘key’ based on their hierarchy. Example:</p> <ul> <li><code class="language-plaintext highlighter-rouge">git config --global credential.UseHttpPath true</code></li> <li> <code class="language-plaintext highlighter-rouge">git config --local</code>, By default, git config use local level:<code class="language-plaintext highlighter-rouge">.git/config</code> </li> <li> <code class="language-plaintext highlighter-rouge">git config --global</code>, global flag: <code class="language-plaintext highlighter-rouge">~ /.gitconfig</code> </li> <li> <code class="language-plaintext highlighter-rouge">git config --system</code>, <code class="language-plaintext highlighter-rouge">$(prefix)/etc/gitconfig</code> </li> <li> <code class="language-plaintext highlighter-rouge">git config --list</code> list the content of the configuration file. for global file: <code class="language-plaintext highlighter-rouge">git config --list --global</code> </li> <li> <code class="language-plaintext highlighter-rouge">git config --global --edit</code> edit the config file. Content of configuration file <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>-- credential
-- user
-- editor - core.editor
-- Merge tools
-- Colored outputs
-- Formatting &amp; whitespace
</code></pre></div> </div> </li> <li>Aliases: <code class="language-plaintext highlighter-rouge">git config --global alias.ci commit</code> Git aliases allow you to create shortcuts for frequently used Git operations. The term alias is synonymous with a shortcut. Aliases are used to create shorter commands that map to longer commands. no direct git alias, but you can: <code class="language-plaintext highlighter-rouge">git config --global alias.co checkout</code> </li> </ul> <h4 id="command-git-remote-set-url">Command <code class="language-plaintext highlighter-rouge">git remote set-url</code> </h4> <p>Changes an existing remote repository URL.</p> <h4 id="command-git-remote-rename">Command <code class="language-plaintext highlighter-rouge">git remote rename</code> </h4> <p>Rename an existing remote.</p> <h4 id="command-git-remote-rm">Command <code class="language-plaintext highlighter-rouge">git remote rm</code> </h4> <p>Remove a remote URL from your repository.</p> <h2 id="saving-changes">Saving changes</h2> <p><code class="language-plaintext highlighter-rouge">git add git commit git diff git stash .gitignore</code></p> <h3 id="command-git-add">Command <code class="language-plaintext highlighter-rouge">Git add</code> </h3> <p>The <code class="language-plaintext highlighter-rouge">git add</code> command adds a change in the working directory to the staging area. And this ‘stage’ changes will be stored in a commit. However, <code class="language-plaintext highlighter-rouge">git add</code> doesn’t really affect the repository in any significant way—changes are not actually recorded until you run git commit.</p> <blockquote> <p>What is Staging area The staging area is considered one of the “three trees” of Git, along with, the working directory, and the commit history. The stage lets you group related changes into highly focused snapshots before actually committing it to the project history</p> </blockquote> <ul> <li> <code class="language-plaintext highlighter-rouge">git add -p</code>, Begin an interactive staging session that lets you choose portions of a file to add to the next commit.</li> </ul> <h3 id="command-git-commit">Command Git commit</h3> <p>The <code class="language-plaintext highlighter-rouge">git commit</code> command captures a snapshot of the project’s currently staged changes. How it work</p> <ul> <li>At a high-level, Git can be thought of as a timeline management utility.</li> <li>git commit is used to create a snapshot of the staged changes along a timeline of a Git projects history.</li> <li>Commits can be thought of as snapshots along the timeline of a Git project.</li> <li>Commits are created with the git commit command to capture the state of a project at that point in time.</li> <li>Git’s version control model is based on snapshots.</li> <li>Git records the entire contents of each file in every commit.</li> </ul> <h3 id="command-git-diff">Command Git diff</h3> <p>Diffing is a function that takes two input data sets and outputs the changes between them. <code class="language-plaintext highlighter-rouge">git diff</code> is a multi-use Git command that when executed runs a diff function on Git data sources, like commits, branches, files. The <code class="language-plaintext highlighter-rouge">git diff</code> command is often used along with <code class="language-plaintext highlighter-rouge">git status</code> and <code class="language-plaintext highlighter-rouge">git log</code> to analyze the current state of a Git repo.</p> <h4 id="show-any-uncommitted-changes-since-the-last-commit-across-the-entire-repository">Show any uncommitted changes since the last commit, across the entire repository:</h4> <p>Use <code class="language-plaintext highlighter-rouge">git diff</code>.</p> <h4 id="comparing-files-showing-the-changes-that-are-not-staged-yet">Comparing files, showing the changes that are not staged yet:</h4> <p><code class="language-plaintext highlighter-rouge">git diff ./path/to/file</code> equal to: <code class="language-plaintext highlighter-rouge">git diff HEAD ./path/to/file</code>. It will compare file in the working directory, against the index, showing the changes that are not staged yet.</p> <h4 id="compare-the-staged-changes-with-the-local-repository">Compare the staged changes with the local repository:</h4> <p>Use <code class="language-plaintext highlighter-rouge">git diff --cached ./path/to/file</code>. (The <code class="language-plaintext highlighter-rouge">--cached</code> option is synonymous with <code class="language-plaintext highlighter-rouge">--staged</code>.)</p> <h4 id="comparing-files-between-two-different-commits">Comparing files between two different commits:</h4> <p>You can pass Git refs (like HEAD, tags, and branch names) to <code class="language-plaintext highlighter-rouge">git diff</code> to commits to diff. Every commit in Git has a commit ID which you can get when you execute GIT LOG. You can also pass this commit ID to <code class="language-plaintext highlighter-rouge">git diff</code>. For example: <code class="language-plaintext highlighter-rouge">git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a</code>.</p> <h4 id="comparing-branches">Comparing branches:</h4> <p><code class="language-plaintext highlighter-rouge">git diff branch1..branch2</code></p> <h4 id="comparing-a-file-from-two-branches">Comparing a file from two branches:</h4> <p><code class="language-plaintext highlighter-rouge">git diff main new_branch ./path/to/file</code></p> <h4 id="comparing-a-file-from-two-commits">Comparing a file from two commits????</h4> <p>????</p> <h3 id="command-git-stash">Command <code class="language-plaintext highlighter-rouge">git stash</code> </h3> <p><code class="language-plaintext highlighter-rouge">git stash</code> temporarily stashes changes you’ve made to your working copy so you can work on something else, and then come back and re-apply them later on. You can reapply previously stashed changes with <code class="language-plaintext highlighter-rouge">git stash pop</code>. Popping your stash removes the changes from your stash and reapplies them to your working copy.</p> <h3 id="gitignore-file">.gitignore file</h3> <p>Git sees every file in your working copy as one of three things:</p> <ul> <li>tracked - a file which has been previously staged or committed;</li> <li>untracked - a file which has not been staged or committed; or</li> <li>ignored - a file which Git has been explicitly told to ignore.</li> </ul> <h2 id="undoing-changes">Undoing Changes</h2> <p><code class="language-plaintext highlighter-rouge">git checkout git clean git revert git reset git rm</code></p> <h3 id="reviewing-old-commit">Reviewing old commit</h3> <ul> <li>We use <code class="language-plaintext highlighter-rouge">git log</code> to get a list of the latest commits. <code class="language-plaintext highlighter-rouge">git log --branches=*</code> get the commits for specific branch. <code class="language-plaintext highlighter-rouge">git log --oneline</code> can be a easier way.</li> <li>When you have found a commit reference to the point in history you want to visit, you can utilize the <code class="language-plaintext highlighter-rouge">git checkout</code> command to visit that commit.</li> <li> <code class="language-plaintext highlighter-rouge">Git checkout</code> is an easy way to “load” any of these saved snapshots onto your development machine.</li> </ul> <figure> <picture> <img src="/assets/img/git-reviewcommit.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="undo-commit-with-git-checkout">Undo commit with <code class="language-plaintext highlighter-rouge">git checkout</code> </h3> <p>Detached HEAD state</p> <ul> <li>When you check out a previous commit, for example: <code class="language-plaintext highlighter-rouge">git checkout a1e8fb5</code>. And then HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state.</li> <li>In a detached state, any new commits you make will be orphaned when you change branches back to an established branch. So don’t commit in Detached HEAD state!</li> <li>To prevent orphaned commits from being garbage collected, we need to ensure we are on a branch: From the detached HEAD state, we can execute git checkout -b new_branch. This will create a new branch named new_branch and switch to that state.</li> <li>At this point, we can continue work on this new branch in which the <code class="language-plaintext highlighter-rouge">872fa7e</code> commit no longer exists and consider it ‘undone’.</li> <li> <p>Sometime, this is not a appropriate way, for example for public shared repositories. But You can use git revert</p> </li> <li>NOTE: Checking out an old file does not move the HEAD pointer. It remains on the same branch and same commit, avoiding a ‘detached head’ state. You can then commit the old version of the file in a new snapshot as you would any other changes. So, in effect, this usage of git checkout on a file, serves as a way to revert back to an old version of an individual file.</li> </ul> <h3 id="undo-a-commit-with-git-revert">Undo a commit with <code class="language-plaintext highlighter-rouge">git revert</code> </h3> <ul> <li> <code class="language-plaintext highlighter-rouge">git revert</code> is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see git-reset.</li> <li> <code class="language-plaintext highlighter-rouge">git revert</code> figures out how to invert the changes introduced by the commit and appends a new commit with the resulting inverse content.</li> <li>Reverting should be used when you want to apply the inverse of a commit from your project history.</li> <li>if you’re tracking down a bug and find that it was introduced by a single commit. Instead of manually going in, fixing it, and committing a new snapshot, you can use <code class="language-plaintext highlighter-rouge">git revert</code> to automatically do all of this for you.</li> <li>It’s important to understand that <code class="language-plaintext highlighter-rouge">git revert</code> undoes a single commit—it does not “revert” back to the previous state of a project by removing all subsequent commits. git reset do that!</li> <li> <code class="language-plaintext highlighter-rouge">git revert</code> prevents Git from losing history.</li> <li> <code class="language-plaintext highlighter-rouge">git revert</code> is the ideal ‘undo’ method for working with public shared repositories.</li> </ul> <p>Using <code class="language-plaintext highlighter-rouge">git revert</code>:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">git revert</code> expects a commit ref was passed in.</li> <li>If we pass HEAD in: <code class="language-plaintext highlighter-rouge">git revert</code> HEAD, Git will create a new commit with the inverse of the latest commit.</li> <li>This adds a new commit to the current branch history and now makes it look like:</li> </ul> <figure> <picture> <img src="/assets/img/git-reverse.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>At this point, we have again technically ‘undone’ the 872fa7e commit.</li> </ul> <h3 id="undo-a-commit-with-git-reset">Undo a commit with <code class="language-plaintext highlighter-rouge">git reset</code> </h3> <ul> <li> <code class="language-plaintext highlighter-rouge">git reset</code> - Reset current HEAD to the specified state.</li> <li> <code class="language-plaintext highlighter-rouge">git reset</code> is a complex and versatile tool for undoing changes.</li> <li>It has three primary forms of invocation. These forms correspond to command line arguments –soft, –mixed, –hard.</li> <li>The three arguments each correspond to Git’s three internal state management mechanism’s, The Commit Tree (HEAD), The Staging Index, and The Working Directory.</li> </ul> <p>Using <code class="language-plaintext highlighter-rouge">git reset</code>:</p> <ul> <li>If we invoke <code class="language-plaintext highlighter-rouge">git reset --hard a1e8fb5</code> for this example, the commit history is reset to that specified commit.</li> </ul> <figure> <picture> <img src="/assets/img/git-reset.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>The log output shows the e2f9a78 and 872fa7e commits no longer exist in the commit history.</li> <li>This method of undoing changes has the cleanest effect on history, comparing <code class="language-plaintext highlighter-rouge">git revert</code>.</li> <li>But git revert method is not good for shared remote repository. <code class="language-plaintext highlighter-rouge">git reset</code> should generally be considered a ‘local’ undo method.</li> </ul> <h3 id="undoing-the-last-commit">Undoing the last commit</h3> <p><code class="language-plaintext highlighter-rouge">git commit --amend</code>. This will have Git open the configured system editor and let you modify the last commit message. The new changes will be added to the amended commit.</p> <h3 id="command-git-clean">Command <code class="language-plaintext highlighter-rouge">Git clean</code> </h3> <ul> <li> <code class="language-plaintext highlighter-rouge">git clean</code> is a convenience method for deleting untracked files in a repo’s working directory.</li> <li> <code class="language-plaintext highlighter-rouge">git clean</code> will make a hard filesystem deletion. Make sure you really want to delete the untracked files before you run it.</li> <li> <code class="language-plaintext highlighter-rouge">git clean</code> is to some extent an ‘undo’ command. <code class="language-plaintext highlighter-rouge">git clean</code> can be considered complementary to other commands like g<code class="language-plaintext highlighter-rouge">it reset</code> and <code class="language-plaintext highlighter-rouge">git checkout</code> to fully undo any additions and commits in a repository.</li> </ul> <p>Options:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">git clean -n</code> will perform a “dry run”.</li> <li> <code class="language-plaintext highlighter-rouge">git clean -f</code> The force option initiates the actual deletion of untracked files from the current directory.</li> </ul> <h3 id="undo-changes-conclusion">Undo Changes Conclusion</h3> <ul> <li>get information: <code class="language-plaintext highlighter-rouge">git status, git log</code> </li> <li>undo local unstaged changes: <code class="language-plaintext highlighter-rouge">git restore filename</code> </li> <li>undo local staged changes: <code class="language-plaintext highlighter-rouge">git restore --staged filename</code> </li> <li>undo latest local commit, and still keep the changes: <code class="language-plaintext highlighter-rouge">git reset --soft HEAD~</code> </li> <li>undo public committed changes. Following command will undo the changes by creating a new commit and reverting that file to its previous state, as if it never changed: <code class="language-plaintext highlighter-rouge">git revert cc3bbf7 --no-edit</code> </li> </ul> <h2 id="collaborating-whit-git">Collaborating whit Git</h2> <p>Git is designed to give each developer an entirely isolated development environment. This means that information is not automatically passed back and forth between repositories. Instead, developers need to manually pull upstream commits into their local repository or manually push their local commits back up to the central repository. Git is different from SVN which uses a single centralized repository to serve as the communication hub for developers.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote, 
git fetch, 
git push,
git pull
</code></pre></div></div> <h3 id="command-git-remote">Command <code class="language-plaintext highlighter-rouge">git remote</code> </h3> <p>The <code class="language-plaintext highlighter-rouge">git remote</code> command is essentially an interface for managing a list of remote entries that are stored in the repository’s ./.git/config file. That means the <code class="language-plaintext highlighter-rouge">git remote</code> command lets you create, view, and delete connections to other repositories.</p> <h4 id="what-is-remote-connections">What is Remote connections</h4> <ul> <li>Remote connections are more like <strong>bookmarks</strong> rather than direct links to other repositories.</li> <li>Remote connections are stored in the repository’s <code class="language-plaintext highlighter-rouge">./.git/config</code> file.</li> <li>Once using git clone, a record have been created in <code class="language-plaintext highlighter-rouge">./.git/config</code> </li> <li>These connections can be central repo or another developer’s repo.</li> </ul> <h4 id="fetching-and-pulling-from-git-remotes">Fetching and pulling from Git remotes</h4> <p>Once a remote record has been configured through the use of the git remote command, the remote name can be passed as an argument to other Git commands to communicate with the remote repo. Both <code class="language-plaintext highlighter-rouge">git fetch</code>, and <code class="language-plaintext highlighter-rouge">git pull</code> can be used to read from a remote repository. The <code class="language-plaintext highlighter-rouge">git remote</code> command is really just an easier way to pass URLs to these “sharing” commands.</p> <h3 id="command-git-fetch">Command <code class="language-plaintext highlighter-rouge">git fetch</code> </h3> <p><code class="language-plaintext highlighter-rouge">git fetch</code> is a primary command used to download contents from a remote repository. And then you can update a local repository to the state of a remote. Git isolates fetched content from existing local content; <strong>it has absolutely no effect on your local development work.</strong> This makes fetching a safe way to review commits before integrating them with your local repository. Fetched content has to be explicitly checked out using the <code class="language-plaintext highlighter-rouge">git checkout</code> command.</p> <p>You need to use <code class="language-plaintext highlighter-rouge">git checkout</code> to checkout what you have fetched, And then <code class="language-plaintext highlighter-rouge">git merge</code> it to your Repo.</p> <h3 id="command-git-pull">Command <code class="language-plaintext highlighter-rouge">git pull</code> </h3> <p>The <code class="language-plaintext highlighter-rouge">git pull</code> command is used to fetch content from a remote repository and immediately update the local repository to match that content.</p> <p>pull process detail:</p> <ul> <li>In the first stage of operation <code class="language-plaintext highlighter-rouge">git pull</code> will execute a git fetch scoped to the local branch that HEAD is pointed at.</li> <li>Once the content is downloaded, <code class="language-plaintext highlighter-rouge">git pull</code> will enter a merge workflow. A new merge commit will be created and HEAD updated to point at the new commit.</li> </ul> <h4 id="scenario">Scenario</h4> <p>Assume we have a repository with a main branch and a remote origin:</p> <figure> <picture> <img src="/assets/img/gitpull-scenario1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In this scenario, there are 2 merging strategies:</p> <h4 id="first-one-git-pull">First one: <code class="language-plaintext highlighter-rouge">git pull</code> </h4> <p><code class="language-plaintext highlighter-rouge">git pull</code> will download all the changes from the point where the local and main diverged. In this example, that point is E. <code class="language-plaintext highlighter-rouge">git pull</code> will fetch the diverged remote commits which are A-B-C. The pull process will then create a new local merge commit containing the content of the new diverged remote commits.</p> <figure> <picture> <img src="/assets/img/gitpull-Senario2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>New commit <code class="language-plaintext highlighter-rouge">H</code> is a new merge commit that contains the contents of remote <code class="language-plaintext highlighter-rouge">A-B-C</code> commits and has a combined log message.</p> <h4 id="second-one-git-pull---rebase">Second one: <code class="language-plaintext highlighter-rouge">git pull --rebase</code> </h4> <figure> <picture> <img src="/assets/img/gitpull-scenoira3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>A rebase pull does not create the new <code class="language-plaintext highlighter-rouge">H</code> commit. Instead, the rebase has copied the remote commits <code class="language-plaintext highlighter-rouge">A--B--C</code> and rewritten the local commits <code class="language-plaintext highlighter-rouge">E--F--G</code> to appear after them in the local origin/main commit history.</li> <li>Means <code class="language-plaintext highlighter-rouge">git pull -rebase</code> == <code class="language-plaintext highlighter-rouge">git fetch + git rebase</code>(instead of <code class="language-plaintext highlighter-rouge">git merge</code>)</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">--rebase</code> option can be used to ensure a linear history by preventing unnecessary merge commits. It’s like saying, <strong>“I want to put my changes on top of what everybody else has done.”</strong>. <code class="language-plaintext highlighter-rouge">--rebase</code> is so common, that have a command like this: <code class="language-plaintext highlighter-rouge">git config --global branch.autosetuprebase always</code></p> <h4 id="git-pull-vs-git-fetch"> <code class="language-plaintext highlighter-rouge">git pull</code> vs. <code class="language-plaintext highlighter-rouge">git fetch</code> </h4> <p>Both git pull and git fetch can download content from a remote repo.</p> <ul> <li>git fetch is safer, pull == fetch + merge.</li> <li>git pull is aggressive, it will download the remote content for the active local branch and immediately execute git merge to create a merge commit for the new remote content.</li> </ul> <h3 id="command-git-push">Command <code class="language-plaintext highlighter-rouge">git push</code> </h3> <p>The <code class="language-plaintext highlighter-rouge">git push</code> command is used to upload local repository content to a remote repository. Pushing is how you transfer commits from your local repository to a remote repo. <code class="language-plaintext highlighter-rouge">git push</code> is essentially the same as running <code class="language-plaintext highlighter-rouge">git merge main</code> from inside the remote repository. Do not use the <code class="language-plaintext highlighter-rouge">--force</code> flag unless you’re absolutely sure you know what you’re doing. It will force the push even if it results in a non-fast-forward merge.</p> <figure> <picture> <img src="/assets/img/gitpush.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h4 id="standard-methods-for-publishing-local-contributions-to-the-central-repository">Standard methods for publishing local contributions to the central repository.</h4> <ul> <li>First, <code class="language-plaintext highlighter-rouge">git fetch</code>! it makes sure your local main is up-to-date by fetching the central repository’s copy and rebasing your changes on top of them.</li> <li>The interactive rebase is also a good opportunity to clean up your commits before sharing them.</li> <li>Then, the <code class="language-plaintext highlighter-rouge">git push</code> command sends all of the commits on your local main to the central repository.</li> </ul> <h4 id="step">Step:</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout main
git fetch origin main
git rebase -i origin/main
# Squash commits, fix up commit messages etc.
git push origin main
</code></pre></div></div> <h3 id="pull-request">Pull Request</h3> <p>What is Pull Request</p> <ul> <li>A Pull Request is the primary way you and other repository users can review, comment on, and merge code changes from one branch to another.</li> <li>Pull Requests are a mechanism for a developer to notify team members that they have completed a feature. Once their feature branch is ready, the developer files a Pull Request. This lets everybody involved know that they need to review the code and merge it into the main branch.</li> <li>The Pull Request is more than just a notification—it’s a dedicated forum for discussing the proposed feature. If there are any problems with the changes, teammates can post feedback in the Pull Request and even tweak the feature by pushing follow-up commits. All of this activity is tracked directly inside of the Pull Request.</li> </ul> <figure> <picture> <img src="/assets/img/pullrequest.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>When you file a Pull Request, all you’re doing is requesting that another developer (e.g., the project maintainer) pulls a branch from your repository into their repository.</li> </ul> <h2 id="using-branch">Using Branch</h2> <p>Git branches are an integral part of your everyday workflow. Unlike SVN branches which are expensive and only used to capture the occasional large-scale development effort.</p> <ul> <li>A branch represents an independent line of development.</li> <li>Branches serve as an abstraction for the edit/stage/commit process.</li> <li>You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.</li> <li>Remember, branches are just names for commits?? NO! Branches are references.</li> </ul> <h3 id="command-git-branch">Command <code class="language-plaintext highlighter-rouge">git branch</code> </h3> <p>The <code class="language-plaintext highlighter-rouge">git branch</code> command lets you create, list, rename, and delete branches.</p> <p><code class="language-plaintext highlighter-rouge">git branch</code> doesn’t let you switch between branches or put a forked history back together again. For this reason, <code class="language-plaintext highlighter-rouge">git branch</code> is tightly integrated with the <code class="language-plaintext highlighter-rouge">git checkout</code> and <code class="language-plaintext highlighter-rouge">git merge</code> commands.</p> <h3 id="command-git-checkout">Command <code class="language-plaintext highlighter-rouge">git checkout</code> </h3> <ul> <li>The <code class="language-plaintext highlighter-rouge">git checkout</code> command lets you navigate between the branches created by git branch.</li> <li>The <code class="language-plaintext highlighter-rouge">git checkout</code> command operates upon three distinct entities: files, commits, and branches.</li> <li>Checking out a branch updates the files in the working directory to match the version stored in that branch, and it tells Git to record all following new commits on that branch.</li> <li>Think of <code class="language-plaintext highlighter-rouge">git checkout</code> as a way to select which line of development you’re working on.</li> </ul> <h3 id="command-git-merge">Command <code class="language-plaintext highlighter-rouge">git merge</code> </h3> <ul> <li>The <code class="language-plaintext highlighter-rouge">git merge</code> command lets you take the independent lines of development created by git branch and integrate them into a single branch.</li> <li>Merge involve some strategy and algorithms and it is main part when operate git.</li> <li>Git can automatically merge commits if no any conflict</li> </ul> <p>Default process: create a new <strong>“merge commit”</strong>:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">git merge</code> takes two commit pointers, usually the branch tips, and will find a common base commit between them. And then it create a new “merge commit” that combines the changes of each queued merge commit sequence.</li> </ul> <figure> <picture> <img src="/assets/img/gitmerge.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h4 id="fast-forward-merge">Fast Forward Merge</h4> <ul> <li>If no conflict, then it is Fast Forward Merge.</li> <li>Moving the current branch tip up to the target branch tip. This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one.</li> </ul> <figure> <picture> <img src="/assets/img/gitmerge-FF.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>Process looks like below: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>git checkout -b new-feature main
git add &lt;file&gt;
git commit -m "featuring"
# Merge in the new-feature branch
git checkout main
git merge new-feature
git branch -d new-feature
</code></pre></div> </div> </li> <li>However, a fast-forward merge is not possible if the branches have diverged.</li> </ul> <h4 id="3-way-merge">3-way merge</h4> <figure> <picture> <img src="/assets/img/gitmerge-3way.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>3-Way merge Process:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout -b new-feature main
git add &lt;file&gt;
git commit -m "Start a feature"
# Develop the main branch
git checkout main
git add &lt;file&gt;
git commit -m "Make some super-stable changes to main"
# Merge in the new-feature branch. But it might conflict.
git merge new-feature
git branch -d new-feature
</code></pre></div></div> <p>Git can automatically merge commits if no any conflict. If conflict, then go to ‘Git merge conflicts’ section below.</p> <h3 id="command-git-rebase">Command <code class="language-plaintext highlighter-rouge">git rebase</code> </h3> <ul> <li>Rebase is one of two Git utilities that specializes in integrating changes from one branch onto another. Another one is <code class="language-plaintext highlighter-rouge">git merge</code>.</li> <li>Merge is always a forward moving change record. Alternatively, rebase has powerful history rewriting features.</li> <li>Rebase itself has 2 main modes: “manual” and “interactive” mode.</li> <li>Rebasing is the process of moving or combining a sequence of commits to a new base commit.</li> <li>Rebasing is most useful and easily visualized in the context of a feature branching workflow.</li> </ul> <figure> <picture> <img src="/assets/img/gitrebase.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>From a content perspective, rebasing is changing the base of your branch from one commit to another making it appear as if you’d created your branch from a different commit.</li> <li>Internally, Git accomplishes this by creating new commits and applying them to the specified base.</li> <li>It’s very important to understand that even though the branch looks the same, it’s composed of entirely new commits.</li> <li>The primary reason for rebasing is to <strong>maintain a linear project history</strong>. This gives the later benefit of a clean merge of your feature branch back into the main branch.</li> </ul> <h3 id="git-merge-conflicts">Git merge conflicts</h3> <ul> <li>If the two branches you’re trying to merge both changed the same part of the same file, Git won’t be able to figure out which version to use.</li> <li>git is using edit/stage/commit workflow to resolve merge conflicts.</li> <li><strong>git status can guild you.</strong></li> <li>Conflicts only affect the developer conducting the merge, the rest of the team is unaware of the conflict.</li> <li>Git will mark the file as being conflicted and halt the merging process. It is then the developers’ responsibility to resolve the conflict.</li> <li>Git provide commands to resolve the conflict. Like <code class="language-plaintext highlighter-rouge">git log</code>, <code class="language-plaintext highlighter-rouge">git reset</code>, <code class="language-plaintext highlighter-rouge">git status</code>, <code class="language-plaintext highlighter-rouge">git checkout</code>.</li> </ul> <p>Merge Strategies:</p> <ul> <li>The git merge and git pull commands can be passed an -s (strategy) option. Like: <code class="language-plaintext highlighter-rouge">git merge -s recursive branch1 branch2</code> </li> <li>Strategy can be: • Recursive(default) • Resolve • Octopus • Ours • Subtree</li> </ul> </div> </article> </div> <div class="col-sm-3 post-side-container"> <div class="card hoverable post-side-sticky"> <div class="card-body post-side-detail"> <h5 class="card-title">Post Detail</h5> <div class="detail-item"> <div class="item-title">Published : </div> <div class="item-content">Mar 8, 2021</div> </div> <div class="detail-item"> <div class="item-title">Category : </div> <div class="item-content"> <a href="/blog/category/git"> <i class="fas fa-tag fa-sm"></i> Git</a> </div> </div> <div class="detail-item"> <div class="item-title">Tags : </div> </div> <div class="tags"> <a href="/blog/tag/git"> <div class="tag"> Git </div> </a> </div> <div class="detail-item"> <div class="item-title">Content : </div> </div> <div class="toc-container"> <div class="toc-item"> <a href="#basic-git-operations"> # Basic git Operations </a> </div> <div class="toc-item"> <a href="#setting-up-a-repo"> # Setting up a repo </a> </div> <div class="toc-item"> <a href="#saving-changes"> # Saving changes </a> </div> <div class="toc-item"> <a href="#undoing-changes"> # Undoing Changes </a> </div> <div class="toc-item"> <a href="#collaborating-whit-git"> # Collaborating whit Git </a> </div> <div class="toc-item"> <a href="#using-branch"> # Using Branch </a> </div> </div> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Ben Wen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/jquery.min.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="/assets/js/tex-mml-chtml.js?d41d8cd98f00b204e9800998ecf8427e"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>