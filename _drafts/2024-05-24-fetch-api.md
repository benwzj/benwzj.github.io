---
layout: post
title: Next.js Fetch data
date: 2024-05-24
category: JavaScript
tags: Next.js JavaScript
toc: 
  - name: Fetch API
    subsections:
      - name: Using the Fetch API Steps
      - name: Making a request
      - name: Reading response 
  - name: fetch vs axios
  - name: Next.js extends fetch
  - name: References
---

## Fetch API

The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses.

Fetch is the modern replacement for `XMLHttpRequest`: unlike `XMLHttpRequest`, which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS).

### Using the Fetch API Steps
- Make a request by calling `fetch()`.
- pass it a `Request` object or a string containing the URL to fetch, along with an optional argument to configure the request.
- The `fetch()` function returns a `Promise` which is fulfilled with a `Response` object representing the server's response. 
- You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response.

The minimal example:
```js
async function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error(error.message);
  }
}
```

### Making a request
#### Setting a body
The request body is the payload of the request: it's the thing the client is sending to the server.
You don't need a body with `GET` requests, but it's useful for requests that send content to the server, such as `POST` or `PUT` requests.

```js
const response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  // ...
});
```
`body` can be a string or ArrayBuffer, TypedArray etc.

#### Setting headers
Request headers give the server information about the request: for example, the `Content-Type` header tells the server the format of the request's body.
You can pass an object literal here containing `header-name: header-value` properties.
```js
const response = await fetch("https://example.org/post", {
  headers: {
    "Content-Type": "application/json",
    'X-Shopify-Storefront-Access-Token': 'key-eikdjsa;je;fmdjasiopej4f4t3g324r4',
  },
  // .,.
});
```
#### Making cross-origin requests
`mode` option, three values: cors, no-cors, or same-origin.

By default, `mode` is set to `cors`, meaning that if the request is cross-origin then it will use the **Cross-Origin Resource Sharing (CORS) mechanism**. 
There are two kinds requests:
- **simple request**: the request will always be sent, but the server must respond with the correct `Access-Control-Allow-Origin` header or the browser will not share the response with the caller.
- **preflighted request**: browser will send a preflighted request to check that the server understands CORS and allows the request, and the real request will not be sent unless the server responds to the preflighted request with the appropriate CORS headers.

Setting `mode` to `same-origin` disallows cross-origin requests completely.
Setting `mode` to `no-cors` means the request must be a simple request, which restricts the headers that may be set, and restricts methods to GET, HEAD, and POST.

### Reading response 
Request and response bodies are actually `ReadableStream` objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like `json()`.

Reading the response body methods: 
```js
Response.arrayBuffer()
Response.blob()
Response.formData()
Response.json()
Response.text()
```
You can read status, type, headers as well.

## Fetch vs Axios

### What is Axios

Axios is a third-party library, a promise-based third-party HTTP client library for the browser and Node.js. 
It provides an easy-to-use API and offers features such as making asynchronous requests, handling request and response interception, and automatic transformation of JSON data.

### Sending a GET Request with Query Parameters:
```js
// Axios
axios.get('/api/data', {
  params: {
    name: 'Alice',
    age: 25
  }
})
.then(response => {
  // handle response
})
.catch(error => {
  // handle error
});

// Fetch
const url = new URL('/api/data');
url.searchParams.append('name', 'Alice');
url.searchParams.append('age', 25);

fetch(url)
.then(response => response.json())
.then(data => {
  // handle data
})
.catch(error => {
  // handle error
});
```

### Sending a POST Request with a JSON Body
```js
// Axios
axios.post('/api/data', {
  name: 'Bob',
  age: 30
})
.then(response => {
  // handle response
})
.catch(error => {
  // handle error
});

// Fetch
fetch('/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Bob',
    age: 30
  })
})
.then(response => response.json())
.then(data => {
  // handle data
})
.catch(error => {
  // handle error
});
```

### Setting a Timeout for the Request:
```js
// Axios
axios.get('/api/data', {
  timeout: 5000 // 5 seconds
})
.then(response => {
  // handle response
})
.catch(error => {
  // handle error
});

// Fetch
const controller = new AbortController();
const signal = controller.signal;

setTimeout(() => {
  controller.abort(); // abort after 5 seconds
}, 5000);

fetch('/api/data', { signal })
.then(response => response.json())
.then(data => {
  // handle data
})
.catch(error => {
  // handle error
});
```
### Using async/await syntax:
```js
// Axios
async function getData() {
  try {
    const response = await axios.get('/api/data');
    // handle response
  } catch (error) {
    // handle error
  }
}

// Fetch
async function getData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    // handle data
  } catch (error) {
    // handle error
  }
}
```

## Next.js extends fetch

### Fetching Data on the Server with `fetch`

Next.js **extends** the native `fetch` Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server. So you don't need to worry fetch data many time or in many places.

React extends `fetch` to automatically memoize fetch requests while rendering a React component tree.

You can use `fetch` with `async/await` in Server Components, in Route Handlers, and in Server Actions.


## References

- [Using Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)
- [What is CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)