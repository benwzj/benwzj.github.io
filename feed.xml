<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://benwzj.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://benwzj.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-27T13:29:04+00:00</updated><id>https://benwzj.github.io/feed.xml</id><title type="html">BEN WEN</title><subtitle>A website to show the world of Ben Wen </subtitle><entry><title type="html">Rendering on the Web</title><link href="https://benwzj.github.io/blog/2024/rendering-web/" rel="alternate" type="text/html" title="Rendering on the Web"/><published>2024-05-27T00:00:00+00:00</published><updated>2024-05-27T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/rendering-web</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/rendering-web/"><![CDATA[<p>There are many ways to rendering web application on the web.</p> <ul> <li>Server-side rendering (SSR): Rendering a client-side or universal app to HTML on the server.</li> <li>Static rendering: Producing a separate HTML file for each URL ahead of time.</li> <li>Client-side rendering (CSR): Rendering an app in a browser, using JavaScript to modify the DOM.</li> <li>Rehydration: “Booting up” JavaScript views on the client so they reuse the server-rendered HTML’s DOM tree and data.</li> <li>Prerendering: Running a client-side application at build time to capture its initial state as static HTML.</li> </ul> <p>Performance is the important fact for web application.</p> <ul> <li>Time to First Byte (<strong>TTFB</strong>): The time between clicking a link and the first byte of content loading on the new page.</li> <li>First Contentful Paint (<strong>FCP</strong>): The time when requested content (article body, etc) becomes visible.</li> <li>Interaction to Next Paint (<strong>INP</strong>): A representative metric that assesses whether a page consistently responds quickly to user inputs.</li> <li>Total Blocking Time (<strong>TBT</strong>): A proxy metric for INP that calculates how long the main thread was blocked during page load.</li> </ul> <blockquote class="block-warning"> <p>Broadly speaking, It is encouraged to consider server-side rendering or static rendering over a full rehydration approach.</p> </blockquote> <h2 id="server-side-rendering">Server-side rendering</h2> <p>Server-side rendering generates the full HTML for a page on the server in response to navigation. This avoids additional round trips for data fetching and templating on the client, because the renderer handles them before the browser gets a response.</p> <p>Server-side rendering generally produces a fast FCP.</p> <p>React users can use server DOM APIs or solutions built on them like Next.js for server-side rendering. Vue users can use Vue’s server-side rendering guide or Nuxt. Angular has Universal.</p> <h2 id="static-rendering">Static rendering</h2> <p>Static rendering happens at <strong>build</strong> time. With HTML responses generated in advance, you can deploy static renders to multiple CDNs to take advantage of edge caching.</p> <p>Tools like Gatsby are designed to make developers feel like their application is being rendered dynamically, not generated as a build step. Static site generation tools such as 11ty, Jekyll, and Metalsmith embrace their static nature, providing a more template-driven approach.</p> <h2 id="prerendering">prerendering</h2> <p>static rendering and prerendering behave differently: statically rendered pages are interactive without needing to execute much client-side JavaScript, whereas prerendering improves the FCP of a Single Page Application that must be booted on the client to make pages truly interactive.</p> <p>Prerendering generally needs more JavaScript to become interactive.</p> <h2 id="client-side-rendering">Client-side rendering</h2> <p>Client-side rendering means rendering pages directly in the browser with JavaScript. All logic, data fetching, templating, and routing are handled on the client instead of on the server. The effective outcome is that more data is passed to the user’s device from the server, and that comes with its own set of tradeoffs.</p> <p>The primary downside to client-side rendering is that the amount of JavaScript required tends to grow as an application grows.</p> <h2 id="rehydration-combines-server-side-and-client-side-rendering">Rehydration combines server-side and client-side rendering.</h2> <p>Rehydration is an approach that tries to smooth over the tradeoffs between client-side and server-side rendering by doing both. Navigation requests like full page loads or reloads are handled by a server that renders the application to HTML, then the JavaScript and data used for rendering is embedded into the resulting document. When done carefully, this achieves a fast FCP like server-side rendering, then “picks up” by rendering again on the client.</p> <p>This is an effective solution, but it can have considerable performance drawbacks. The primary downside of server-side rendering with rehydration is that it can have a significant negative impact on TBT and INP, even if it improves FCP.</p> <p>Also, Because this duplicates a lot of HTML, rehydration can cause more problems than just delayed interactivity.</p> <h2 id="stream-server-side-rendering-and-rehydrate-progressively">Stream server-side rendering and rehydrate progressively</h2> <p>Streaming server-side rendering lets you send HTML in chunks that the browser can progressively render as it’s received. This can get markup to your users faster, speeding up your FCP.</p> <p>Progressive rehydration is also worth considering, and React has implemented it. With this approach, individual pieces of a server-rendered application are “booted up” over time, instead of the current common approach of initializing the entire application at once.</p> <h2 id="seo-considerations">SEO considerations</h2> <p>When choosing a web rendering strategy, teams often consider the impact of SEO.</p> <p>Server-side rendering is a popular choice for delivering a “complete looking” experience that crawlers can interpret.</p> <p>Crawlers can understand JavaScript, but there are often limitations to how they render. Client-side rendering can work, but often needs additional testing and overhead. More recently, dynamic rendering has also become an option worth considering if your architecture depends heavily on client-side JavaScript.</p> <h2 id="conclusion">Conclusion</h2> <figure> <picture> <img src="/assets/img/app-rendering-types.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="references">References</h2> <ul> <li><a href="https://web.dev/articles/rendering-on-the-web#seo-considerations">web.dev</a></li> </ul>]]></content><author><name></name></author><category term="Website"/><category term="Website"/><category term="Rendering"/><category term="React"/><summary type="html"><![CDATA[There are many ways to rendering web application on the web. Server-side rendering (SSR): Rendering a client-side or universal app to HTML on the server. Static rendering: Producing a separate HTML file for each URL ahead of time. Client-side rendering (CSR): Rendering an app in a browser, using JavaScript to modify the DOM. Rehydration: “Booting up” JavaScript views on the client so they reuse the server-rendered HTML’s DOM tree and data. Prerendering: Running a client-side application at build time to capture its initial state as static HTML.]]></summary></entry><entry><title type="html">Shopify Theme</title><link href="https://benwzj.github.io/blog/2024/shopify-theme/" rel="alternate" type="text/html" title="Shopify Theme"/><published>2024-05-17T00:00:00+00:00</published><updated>2024-05-17T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/shopify-theme</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/shopify-theme/"><![CDATA[<p>A Shopify theme determines the way that a Shopify online store looks, feels, and functions for merchants and their customers. Different themes have different styles and layouts, and offer a different experience for your customers. For example, if you’re selling spa products, then you might want your online store to feel relaxed and luxurious. If you’re selling electronics, then you might want your online store to look energetic and sleek.</p> <p>Shopify themes are built using Shopify’s theme templating language, Liquid, along with HTML, CSS, JavaScript, and JSON. Using these languages, developers can create any look and feel that their clients want.</p> <blockquote class="block-warning"> <p><a href="https://github.com/Shopify/dawn">Dawn</a> is official, free, default theme. It show What a Theme exactly to be.</p> </blockquote> <h2 id="theme-architecture">Theme architecture</h2> <p>Theme code is organized with a standard directory structure of files specific to Shopify themes, as well as supporting assets such as images, stylesheets, and scripts.</p> <h3 id="theme-files">Theme files</h3> <p>Theme files fall into the following general categories:</p> <ul> <li>Markup and features - These files control the layout and functionality of a theme. They use <strong>Liquid</strong> to generate the HTML markup that makes up the pages of the merchant’s online store.</li> <li>Supporting assets - These files are assets, scripts, or locale files that are either called or consumed by other files in the theme.</li> <li>Config files - These files use <strong>JSON</strong> to store configuration data that can be customized by merchants using the theme editor.</li> </ul> <h3 id="themes-directory-structure">Themes directory structure</h3> <p>Themes must use the following directory structure:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── assets
├── config
├── layout
├── locales
├── sections
├── snippets
└── templates
    └── customers
</code></pre></div></div> <ul> <li>The <code class="language-plaintext highlighter-rouge">assets</code> directory, including image, CSS, and JavaScript files.</li> <li>The <code class="language-plaintext highlighter-rouge">config</code> directory contains the config files for a theme.</li> <li>The <code class="language-plaintext highlighter-rouge">layout</code> directory contains the layout files for a theme, through which template files are rendered. A <code class="language-plaintext highlighter-rouge">theme.liquid</code> file must exist in this folder for the theme to be uploaded to Shopify. Layouts are <strong>Liquid files</strong> that allow you to include content, that should be repeated on multiple page types, in a single location. For example, layouts are a good place to include any content you might want in your <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> element, as well as <code class="language-plaintext highlighter-rouge">headers</code> and <code class="language-plaintext highlighter-rouge">footers</code>. <ul> <li>In JSON templates, the layout that’s used to render a page is specified using the layout attribute.</li> <li>In Liquid templates, the layout that’s used to render a page is specified using the layout Liquid tag.</li> </ul> </li> <li>The <code class="language-plaintext highlighter-rouge">locales</code> directory contains the locale files for a theme, which are used to provide translated content.</li> <li>The <code class="language-plaintext highlighter-rouge">sections</code> directory contains a theme’s sections and section groups. Sections are Liquid files, while Section groups are JSON containers.</li> <li>The <code class="language-plaintext highlighter-rouge">snippets</code> directory contains Liquid files that host smaller reusable snippets of code.</li> <li>The <code class="language-plaintext highlighter-rouge">templates</code> directory contains a theme’s template files, which control what’s rendered on each type of page.</li> <li>The <code class="language-plaintext highlighter-rouge">templates/customers</code> directory contains the template files for customer-centric pages like the login and account overview pages.</li> </ul> <h2 id="template">Template</h2> <p>Templates control what’s rendered on each type of page in a theme. Template files are located in the templates directory of the theme.</p> <h3 id="file-types">File types</h3> <p>There are two different file types you can use for a theme template: JSON and Liquid.</p> <h4 id="json-file">JSON file</h4> <p>JSON templates are data files with the <code class="language-plaintext highlighter-rouge">.json</code> file extension. These templates let you easily populate your template with content from sections. Sections can be added, removed, or rearranged by merchants using the theme editor. If you’re using a JSON template, then any HTML or Liquid code needs to be included in a section that’s referenced by the template. If you want to use sections in a template, then you should use a JSON template. JSON templates provide more flexibility for merchants to add, remove, and reorder sections, including app sections.</p> <h4 id="liquid-file">Liquid file</h4> <p>Liquid templates are Liquid markup files, with the <code class="language-plaintext highlighter-rouge">.liquid</code> file extension. You can add Liquid and HTML directly to Liquid templates.</p> <h3 id="template-types">Template types</h3> <p>Each available template type represents a type of content in a merchant’s online store. For example, to render a product page, you need at least one template of type <code class="language-plaintext highlighter-rouge">product</code>.</p> <p>Template types can be: 404 article blog. cart collection customers/account etc.</p> <h2 id="fqa">FQA</h2> <ul> <li>How Theme work in Shopify</li> </ul> <h2 id="references">References</h2> <ul> <li><a href="https://shopify.dev/docs/themes/architecture">Theme architecture</a></li> </ul>]]></content><author><name></name></author><category term="Website"/><category term="Shopify"/><category term="Liquid"/><category term="Theme"/><summary type="html"><![CDATA[A Shopify theme determines the way that a Shopify online store looks, feels, and functions for merchants and their customers. Different themes have different styles and layouts, and offer a different experience for your customers. For example, if you’re selling spa products, then you might want your online store to feel relaxed and luxurious. If you’re selling electronics, then you might want your online store to look energetic and sleek.]]></summary></entry><entry><title type="html">GraphQL Introduction</title><link href="https://benwzj.github.io/blog/2024/GraphQL/" rel="alternate" type="text/html" title="GraphQL Introduction"/><published>2024-05-11T00:00:00+00:00</published><updated>2024-05-11T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/GraphQL</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/GraphQL/"><![CDATA[<h2 id="graphql-concept">GraphQL Concept</h2> <p>GraphQL is a query <strong>language</strong> for your API, and a server-side runtime for executing queries using a type system you define for your data.</p> <p>Clients form requests by using the GraphQL query language, and the GraphQL server executes the request and returns the data in a response.</p> <h3 id="features">Features</h3> <ul> <li><strong>The GraphQL query language</strong>: basically about <strong>selecting fields</strong> on objects.</li> <li><strong>A GraphQL service</strong>: it is created by defining <strong>types</strong> and <strong>fields on those types</strong>, then providing functions for each field on each type.</li> <li>In <strong>a GraphQL operation</strong>: the client specifies how to structure the data when it is returned by the server. This makes it possible for the client to query only for the data it needs, in the format that it needs it in.</li> <li><strong>GraphQL request structures</strong> resemble JSON. However, GraphQL requests don’t use quotes for field names and don’t have colons separating field names and values. Responses are in JSON format.</li> </ul> <h3 id="graphql-vs-rest">GraphQL vs REST</h3> <p>We usually compare GraphQL and REST.</p> <p>REST uses <strong>“resources”</strong> as its core concept. That means entities are identified by URIs. In contrast, GraphQL’s conceptual model is an entity <strong>graph</strong>. A GraphQL server operates on a single URL/endpoint, usually /graphql, and all GraphQL requests for a given service should be directed at this endpoint.</p> <p>In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. But in GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches.</p> <h3 id="graphql-has-three-top-level-operations">GraphQL has three top-level operations:</h3> <ol> <li>Query - read-only fetch</li> <li>Mutation - write, followed by a fetch</li> <li>Subscription - long-lived connection for receiving data</li> </ol> <p>GraphQL exposes these operations via a schema that defines the capabilities of an API. A schema is comprised of types, which can be root types (query, mutation, or subscription) or user-defined types.</p> <blockquote class="block-warning"> <p>Developers start with a schema to define the capabilities of their GraphQL API, which a client application will communicate with.</p> </blockquote> <h2 id="basic-example">Basic example</h2> <ol> <li>A GraphQL service define object types: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Query {
  me: User
}
type User {
  id: ID
  name: String
}
</code></pre></div> </div> <p>Along with functions for each field on each type:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Query_me</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">request</span><span class="p">.</span><span class="nx">auth</span><span class="p">.</span><span class="nx">user</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nf">User_name</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nf">getName</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>After a GraphQL service is running, it can receive GraphQL queries to and execute. For example, the query: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  me {
 name
  }
}
</code></pre></div> </div> <p>Could produce the following JSON result:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"me"</span><span class="p">:{</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Luke Skywalker"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div> </div> </li> </ol> <h2 id="basic-concepts">Basic Concepts</h2> <ul> <li><strong>Arguments</strong>: (just like arguments in Function()) In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. In GraphQL, every field and nested object can get its own set of arguments. It let you fetch more specific data.</li> <li><strong>Aliases</strong>: They let you rename the result of a field to anything you want.</li> <li><strong>fragments</strong>: (just like Functions) GraphQL includes reusable units called fragments. Fragments let you construct sets of fields, and then include them in queries where you need to.</li> <li>The <strong>Operation Type</strong> is either query, mutation, or subscription and describes what type of operation you’re intending to do.</li> <li>The <strong>Operation Name</strong> is a meaningful and explicit name for your operation.</li> <li><strong>Variables</strong>: (<code class="language-plaintext highlighter-rouge">$variableName: variableType</code>) All declared variables must be either scalars, enums, or input object types.</li> <li>Directives: The core GraphQL specification includes exactly two directives, which must be supported by any spec-compliant GraphQL server implementation: <ul> <li><code class="language-plaintext highlighter-rouge">@include(if: Boolean)</code> Only include this field in the result if the argument is <code class="language-plaintext highlighter-rouge">true</code>.</li> <li><code class="language-plaintext highlighter-rouge">@skip(if: Boolean)</code> Skip this field if the argument is <code class="language-plaintext highlighter-rouge">true</code>.</li> </ul> </li> </ul> <h2 id="graphql-schema-language">GraphQL schema language</h2> <p>The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service, and what fields it has.</p> <h3 id="the-query-and-mutation-types">The Query and Mutation types</h3> <p>Most types in your schema will just be normal object types, but there are two types that are special within a schema:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schema {
  query: Query
  mutation: Mutation
}
</code></pre></div></div> <h3 id="scalar-types">Scalar types:</h3> <p>they represent the leaves of the query.</p> <h3 id="interface-type">Interface type:</h3> <p>An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface. (Like class)</p> <h3 id="union-types">Union types:</h3> <p>Union types are very similar to interfaces, but they don’t get to specify any common fields between the types. <code class="language-plaintext highlighter-rouge">union SearchResult = Human | Droid | Starship</code> Wherever we return a SearchResult type in our schema, we might get a Human, a Droid, or a Starship.</p> <h3 id="input-types">Input types:</h3> <p>in the GraphQL schema language, input types look exactly the same as regular object types, but with the keyword input instead of type:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input ReviewInput {
  stars: Int!
  commentary: String
}
</code></pre></div></div> <p>Input type is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created. You can’t mix input and output types in your schema. Input object types also can’t have arguments on their fields.</p> <h2 id="authorization">Authorization</h2>]]></content><author><name></name></author><category term="Language"/><category term="GraphQL"/><category term="REST"/><summary type="html"><![CDATA[GraphQL Concept]]></summary></entry><entry><title type="html">NPM YARN and PNPM</title><link href="https://benwzj.github.io/blog/2024/npm-pnpm-yarn/" rel="alternate" type="text/html" title="NPM YARN and PNPM"/><published>2024-05-10T00:00:00+00:00</published><updated>2024-05-10T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/npm-pnpm-yarn</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/npm-pnpm-yarn/"><![CDATA[<h2 id="npm">NPM</h2> <p>NPM stands for Node Package Manager. npm is a package manager for the JavaScript programming language maintained by Microsoft’s npm, Inc. npm is the default package manager for the JavaScript runtime environment Node.js and is included as a recommended feature in the Node.js installer.</p> <h3 id="packages">Packages</h3> <p>A package in Node.js contains all the files you need for a module. Modules are JavaScript libraries you can include in your project. A package is registered in npmjs.com registry.</p> <h3 id="about-scopes">About scopes</h3> <p>When you sign up for an npm user account or create an organization, you are granted a scope that matches your user or organization name. You can use this scope as a namespace for related packages.</p> <blockquote class="block-warning"> <p>A scope allows you to create a package with the same name as a package created by another user or organization without conflict.</p> </blockquote> <p>When listed as a dependent in a package.json file, scoped packages are preceded by their scope name. The scope name is everything between the <code class="language-plaintext highlighter-rouge">@</code> and the slash <code class="language-plaintext highlighter-rouge">/</code>:</p> <ul> <li>“npm” scope: <code class="language-plaintext highlighter-rouge">@npm/package-name</code></li> <li>“npmcorp” scope: <code class="language-plaintext highlighter-rouge">@npmcorp/package-name</code></li> </ul> <h4 id="scopes-and-package-visibility">Scopes and package visibility</h4> <p>Unscoped packages are always public. Private packages are always scoped. Scoped packages are private by default; you must pass a command-line flag when publishing to make them public.</p> <h3 id="commonjs">CommonJS</h3> <p>CommonJS is a project to <strong>standardize the module ecosystem</strong> for JavaScript outside of web browsers (e.g. on web servers or native desktop applications).</p> <p>CommonJS’s specification of how modules should work is widely used today for server-side JavaScript with Node.js. It is also used for browser-side JavaScript, but that code must be packaged with a transpiler since browsers don’t support CommonJS.</p> <p>The other major module specification in use is the ECMAScript (ES) modules specification (<strong>ES6 modules</strong> aka ES2015 modules). CommonJS can be recognized by the use of the <code class="language-plaintext highlighter-rouge">require()</code> function and <code class="language-plaintext highlighter-rouge">module.exports</code>, while ES modules use <code class="language-plaintext highlighter-rouge">import</code> and <code class="language-plaintext highlighter-rouge">export</code> statements for similar (though not identical) functionality.</p> <h3 id="use-npm-command">Use npm command</h3> <p>npm manages downloads of dependencies of your project.</p> <ul> <li>If a project has a package.json file, by running <code class="language-plaintext highlighter-rouge">npm install</code>, it will install everything the project needs, in the <code class="language-plaintext highlighter-rouge">node_modules</code> folder, creating it if it’s not existing already.</li> <li>You can also install a specific package by running <code class="language-plaintext highlighter-rouge">npm install &lt;package-name&gt;</code>.</li> <li>Updating packages <code class="language-plaintext highlighter-rouge">npm update</code></li> <li>Running Tasks <code class="language-plaintext highlighter-rouge">npm run &lt;task-name&gt;</code></li> </ul> <h3 id="npx">npx</h3> <p>Run packages without downloading using npx.</p> <h2 id="yarn">YARN</h2> <p>YARN stands for Yet Another Resource Negotiator. It is an alternative package manager for JavaScript that was created in 2016 by Facebook, Google, Exponent, and Tilde. It was designed to address some of the issues and limitations of NPM, such as speed, reliability, and security.</p> <p>YARN has a similar command-line interface as NPM, but with some differences and improvements. It also uses the same package.json file as NPM, but it adds another file called yarn.lock that locks the exact versions of your dependencies. It also creates a node_modules folder where it stores the installed packages.</p> <h3 id="advantages">Advantages</h3> <ul> <li>It is faster and more efficient than NPM when installing or updating packages</li> <li>It uses a flat dependency structure that avoids duplication and nesting of packages</li> <li>It supports offline installation of packages from a local cache</li> <li>It has a better resolution algorithm that ensures consistent and deterministic versions of packages across different environments <h3 id="disadvantages">Disadvantages</h3> </li> <li>It is not as widely used or supported as NPM by the JavaScript community</li> <li>It may not be compatible with some NPM packages or features</li> <li>It may have some bugs or issues that are not yet fixed or resolved</li> </ul> <h2 id="pnpm">PNPM</h2> <p>When using npm, if you have 100 projects using a dependency, you will have 100 copies of that dependency saved on disk. With pnpm, the dependency will be stored in a content-addressable store, so:</p> <ul> <li>If you depend on different versions of the dependency, only the files that differ are added to the store. For instance, if it has 100 files, and a new version has a change in only one of those files, pnpm update will only add 1 new file to the store, instead of cloning the entire dependency just for the singular change.</li> <li>All the files are saved in a single place on the disk. When packages are installed, their files are hard-linked from that single place, consuming no additional disk space. This allows you to share dependencies of the same version across projects.</li> </ul> <p>As a result, you <strong>save a lot of space</strong> on your disk proportional to the number of projects and dependencies, and you have a lot faster installations!</p> <h3 id="boosting-installation-speed">Boosting installation speed</h3> <p>pnpm perfoms installation in three stages:</p> <ul> <li>Dependency resolution. All required dependencies are identified and fetched to the store.</li> <li>Directory structure calculation. The <code class="language-plaintext highlighter-rouge">node_modules</code> directory structure is calculated based on the dependencies.</li> <li>Linking dependencies. All remaining dependencies are fetched and hard linked from the store to <code class="language-plaintext highlighter-rouge">node_modules</code>.</li> </ul> <h3 id="pnpm-creating-a-non-flat-node_modules-directory">pnpm Creating a non-flat node_modules directory</h3> <p><code class="language-plaintext highlighter-rouge">npm</code> and <code class="language-plaintext highlighter-rouge">Yarn</code> create flat node_modules directory.</p> <p>But by default, <code class="language-plaintext highlighter-rouge">pnpm</code> uses <strong>symlinks</strong> to add only the direct dependencies of the project into the root of the modules directory. pnpm Creating a non-flat node_modules directory</p> <h2 id="npm-vs-yarn-vs-pnpm">npm vs yarn vs pnpm</h2> <table> <thead> <tr> <th style="text-align: left">Feature</th> <th style="text-align: left">NPM</th> <th style="text-align: left">YARN</th> <th style="text-align: left">PNPM</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">Speed</td> <td style="text-align: left">Slow</td> <td style="text-align: left">Fast</td> <td style="text-align: left">Faster</td> </tr> <tr> <td style="text-align: left">Disk Space</td> <td style="text-align: left">High</td> <td style="text-align: left">Low</td> <td style="text-align: left">Lower</td> </tr> <tr> <td style="text-align: left">Security</td> <td style="text-align: left">Low</td> <td style="text-align: left">High</td> <td style="text-align: left">Higher</td> </tr> <tr> <td style="text-align: left">Compatibility</td> <td style="text-align: left">High</td> <td style="text-align: left">Medium</td> <td style="text-align: left">Medium</td> </tr> <tr> <td style="text-align: left">Popularity</td> <td style="text-align: left">High</td> <td style="text-align: left">Medium</td> <td style="text-align: left">Low</td> </tr> <tr> <td style="text-align: left">Ecosystem</td> <td style="text-align: left">Rich</td> <td style="text-align: left">Medium</td> <td style="text-align: left">Medium</td> </tr> <tr> <td style="text-align: left">CLI</td> <td style="text-align: left">Simple</td> <td style="text-align: left">Complex</td> <td style="text-align: left">Similar to NPM</td> </tr> <tr> <td style="text-align: left">directory</td> <td style="text-align: left">flattened</td> <td style="text-align: left">flattened</td> <td style="text-align: left">symlinks</td> </tr> </tbody> </table> <h2 id="fqa">FQA</h2> <h3 id="is-it-a-problem-if-mix-using-them-in-a-project">Is it a problem if mix using them in a project?</h3> <p>You can switch between them if you want, as long as you delete the existing node_modules folder and lockfile before installing with a different package manager.</p> <h3 id="lockfile">lockfile?</h3> <p>Use a lockfile to ensure reproducible installs across different machines and environments. A lockfile is a file that records the exact versions and sources of the packages that your project depends on, so that you can install them consistently every time. NPM uses a package-lock.json file, YARN uses a yarn.lock file, and PNPM uses a pnpm-lock.yaml file. You should commit these files to your version control system and update them whenever you add, remove, or update a package</p>]]></content><author><name></name></author><category term="Programming"/><category term="npm"/><category term="Node.js"/><summary type="html"><![CDATA[NPM]]></summary></entry><entry><title type="html">CSS-in-JS Instroduction</title><link href="https://benwzj.github.io/blog/2024/css-in-js/" rel="alternate" type="text/html" title="CSS-in-JS Instroduction"/><published>2024-04-26T00:00:00+00:00</published><updated>2024-04-26T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/css-in-js</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/css-in-js/"><![CDATA[<h2 id="what-is-css-in-js">What is CSS-in-JS</h2> <p>The tradiction way to use CSS in SPA is using global CSS files. But there are some drawbacks in this approach:</p> <ul> <li>Headache in inventing class names.</li> <li>Hard to maintian: Changing one CSS may affect many HTML.</li> <li>Zombies CSS code.</li> </ul> <p>If you write CSS in JavaScript, you can add, change and delete CSS without any unexpected consequences. My changes to the styling of a component will not affect anything else. If you delete a component, you delete its CSS too. No more append-only stylesheets!</p> <h3 id="some-avandtage-of-css-in-js">Some Avandtage of CSS-in-JS:</h3> <ul> <li>Styles/Component co-location: As components include all the source code, styles, and logic they need for proper running, you can securely move them around.</li> <li>Local Scoping: By default, CSS doesn’t allow local scoping. Each style rule has a global scope, so it applies to the entire project.</li> <li>Reusability: Components are reusable, so you only have to write them once, then you can run them everywhere.</li> <li>Dynamic Functionality: As CSS-in-JS is essentially JavaScript code, you can apply complex logic to your style rules, such as loops, conditionals, variables, state-based styling, and more.</li> <li>Provide State-based styling: CSS-in-JS gives developers API to describe state-based styles in a better way than using a bunch of conditional class names.</li> <li>Constrain Selector: CSS-in-JS helps to constrain that power by scoping its selectors. Providing more expressiveness while encouraging more maintainable patterns than cascading.</li> <li>Painless maintenance: you never have to hunt across different files to find the styling affecting your component, so maintenance is a piece of cake no matter how big your codebase is.</li> <li>Automatic vendor prefixing: Most library provide this.</li> <li>Easier deletion of CSS: it can be hard to know whether a class name is used somewhere in your codebase. Write CSS in JS, every bit of styling is tied to a specific component. If the component is unused (which tooling can detect) and gets deleted, all its styles get deleted with it.</li> <li>Automatic critical CSS: styled-components keeps track of which components are rendered on a page and injects their styles and nothing else, fully automatically. Combined with code splitting, this means your users load the least amount of code necessary.</li> <li>No class name bugs: styled-components generates unique class names for your styles. You never have to worry about duplication, overlap or misspellings.</li> </ul> <h3 id="some-popular-css-in-js-library">Some popular CSS-in-JS library:</h3> <ul> <li>styled-components</li> <li>Emotion</li> <li>JSS</li> <li>APHRODITE</li> <li>RADIUM</li> <li>STYLETRON</li> <li>STYLED-JSX</li> </ul> <h2 id="styled-components">styled-components</h2> <p>styled-components is the result of wondering how we could enhance CSS for styling React component systems.</p> <p>It removes the mapping between components and styles. This means that when you’re defining your styles, you’re actually creating a normal React component, that has your styles attached to it.</p> <h3 id="usage">Usage</h3> <p>Install: <code class="language-plaintext highlighter-rouge">npm install styled-component</code> Once you’ve added styled-components you will have access to the global <code class="language-plaintext highlighter-rouge">window.styled</code> variable.</p> <p>It utilises tagged template literals to style your components. Example:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a Title component that'll render an &lt;h1&gt; tag with some styles</span>
<span class="kd">const</span> <span class="nx">Title</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">h1</span><span class="s2">`
  font-size: 1.5em;
  text-align: center;
  color: #e22`</span>
<span class="c1">// Create a Wrapper component that'll render a &lt;section&gt; tag with some styles</span>
<span class="kd">const</span> <span class="nx">Wrapper</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">section</span><span class="s2">`
  padding: 4em;
  background: papayawhip;
`</span><span class="p">;</span>

<span class="c1">// Use Title and Wrapper like any other React component – except they're styled!</span>
<span class="nf">render</span><span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">Wrapper</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Title</span><span class="o">&gt;</span>
      <span class="nx">Hello</span> <span class="nx">World</span><span class="o">!</span>
    <span class="o">&lt;</span><span class="sr">/Title</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/Wrapper</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div> <h2 id="emotion">Emotion</h2> <h3 id="install-it-for-react">Install it for React</h3> <p><code class="language-plaintext highlighter-rouge">npm i @emotion/styled @emotion/react</code></p> <h3 id="example">Example</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">styled</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@emotion/styled</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">button</span><span class="s2">`
  padding: 32px;
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  color: black;
  font-weight: bold;
  &amp;:hover {
    color: white;
  }
`</span>
<span class="nf">render</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Button</span><span class="o">&gt;</span><span class="nx">This</span> <span class="nx">my</span> <span class="nx">button</span> <span class="nx">component</span><span class="p">.</span><span class="o">&lt;</span><span class="sr">/Button&gt;</span><span class="err">)
</span></code></pre></div></div> <h2 id="my-conclusion">My Conclusion</h2> <ul> <li>Every component own it’s style. the CSS code will be very big.</li> <li>How to share style between different components?</li> <li>How use preproccessor, like Sass, to manage style.</li> </ul> <h2 id="references">References</h2> <ul> <li><a href="https://styled-components.com/docs/basics">styled-component basics</a></li> </ul>]]></content><author><name></name></author><category term="CSS"/><category term="React"/><category term="CSS"/><category term="JavaScript"/><summary type="html"><![CDATA[What is CSS-in-JS]]></summary></entry><entry><title type="html">PostCSS Instroduction</title><link href="https://benwzj.github.io/blog/2024/postcss/" rel="alternate" type="text/html" title="PostCSS Instroduction"/><published>2024-04-22T00:00:00+00:00</published><updated>2024-04-22T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/postcss</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/postcss/"><![CDATA[<h2 id="what-is-postcss">What is PostCSS</h2> <p>PostCSS is a JavaScript library that transforms CSS into JavaScript.</p> <p>CSS is transpiled into an abstract syntax tree, which is represented with JavaScript objects. This transformation allows developers the opportunity to manipulate the CSS through those objects. Then, after our CSS has been processed, the objects are converted back into valid CSS.</p> <blockquote> <p>PostCSS will not do anything to our CSS. It’s up to plugins to apply these changes!</p> </blockquote> <p>And as it stands, there are hundreds of plugins available and no shortage of options.</p> <p>Despite its name, it is neither a post-processor nor a pre-processor, it is just a transpiler that turns a special PostCSS plugin syntax into a Vanilla CSS. You can think of it as the Babel tool for CSS.</p> <h2 id="postcss-vs-sass">PostCSS vs SASS</h2> <h3 id="sass">SASS</h3> <p>SASS is preprocessor scripting language for CSS. Built as an extension language to CSS, this preprocessor scripting language allowed Developers to leverage simple programming concepts such as conditional statements and variables for writing CSS, and as a result, working with CSS became so much more enjoyable.</p> <p>The biggest gripe with SASS and preprocessors in general, is that they’re not easily <strong>extendable</strong>.</p> <h3 id="postcss">PostCSS</h3> <p>PostCSS is just born for extendable. You can use PostCSS in conjunction with existing preprocessors like Sass, Less, and Stylus. Or you can use it as an alternative to all of them since it has all the required functionalities to be used alone.</p> <h2 id="set-up-postcss">Set Up PostCSS</h2> <h3 id="using-postcss-cli">Using PostCSS CLI</h3> <p>install CLI</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i postcss-cli
</code></pre></div></div> <p>Then We can run the following command directly in the terminal:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>postcss src/style.css --use postcss-import --dir public --watch
</code></pre></div></div> <h3 id="using-npm-scripts">Using NPM scripts</h3> <p>Inside the <code class="language-plaintext highlighter-rouge">package.json</code> file in the “scripts”, we need to type the following: <code class="language-plaintext highlighter-rouge">"postcss:watch": "postcss src/style.css --use postcss-import --dir public --watch"</code></p> <p>The above command will create a new directory called ‘public’ which contains our final Vanilla CSS file, which has the same name as the source file (style.css).</p> <h3 id="using-postcss-config-file">Using PostCSS Config File</h3> <p>In the root directory of your project, create a file and name it postcss.config.js. The code inside it will look like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
     	<span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">postcss-import</span><span class="dl">'</span><span class="p">),</span>
        <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">postcss-mixins</span><span class="dl">'</span><span class="p">),</span>
        <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">stylelint</span><span class="dl">"</span><span class="p">),</span>
        <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">postcss-preset-env</span><span class="dl">'</span><span class="p">)({</span> <span class="na">stage</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}),</span>
        <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">cssnano</span><span class="dl">'</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div> <p>The command that runs PostCSS in our <code class="language-plaintext highlighter-rouge">package.json</code> file needs to be changed to: <code class="language-plaintext highlighter-rouge">"postcss:watch": "postcss src/style.css --dir public --watch"</code></p> <h3 id="using-task-runners-or-module-bundlers">Using Task Runners (or Module Bundlers)</h3> <p>PostCSS can be set to work with various task runners like Gulp, Grunt, and module bundlers like Rollup and Webpack.</p> <h2 id="postcss-plugin">PostCSS Plugin</h2> <blockquote> <p>The popular CSS framework TailwindCSS can be a PostCSS plugin.</p> </blockquote> <p>You can write your own plugin. SASS, LESS and Stylus can work as a PostCSS plugin to integrate into your work flow.</p> <p>Here list some popular plugins:</p> <h3 id="postcss-import">PostCSS Import</h3> <p>One of the basic and most important plugins to use is postcss-import. It lets us import CSS files into other files. <a href="https://github.com/postcss/postcss-import">github doc</a></p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="s2">'./components/comp1.css'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s2">'./components/comp2.css'</span><span class="p">;</span>
</code></pre></div></div> <h3 id="autoprefixer">Autoprefixer</h3> <p>This is one of the most popular PostCSS plugins. You use it to parse and add vendor prefixes like <code class="language-plaintext highlighter-rouge">-webkit</code>, <code class="language-plaintext highlighter-rouge">-moz</code>, and <code class="language-plaintext highlighter-rouge">-ms</code> to CSS rules using values from the <a href="https://caniuse.com/">Can I Use</a> website.</p> <p>Autoprefixer uses <a href="https://github.com/browserslist/browserslist">Browserslist</a>, so you can specify the browsers you want to target in your project with queries.</p> <p>For example, We can configure our Browserslist in the <code class="language-plaintext highlighter-rouge">package.json</code> file using a “browserslist” key:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="dl">"</span><span class="s2">browserslist</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span> 
    <span class="dl">"</span><span class="s2">defaults</span><span class="dl">"</span>  
 <span class="p">]</span>
</code></pre></div></div> <p>Now it work like this:</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">label</span> <span class="p">{</span>
  <span class="py">user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Based on our previous “browserslist” settings, the final output will be:</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">label</span> <span class="p">{</span>
  <span class="nl">-webkit-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
     <span class="nl">-moz-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
      <span class="nl">-ms-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
          <span class="py">user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="postcss-preset-env">PostCSS Preset Env</h3> <p>This plugin enables us to use modern CSS (like nesting and custom media queries) in our code, by converting it to Vanilla CSS which can be understood by browsers.</p> <p>It has a <code class="language-plaintext highlighter-rouge">stage</code> option which determines which CSS features to polyfill based upon their stability in the process of becoming implemented as a web standard.</p> <p>The <code class="language-plaintext highlighter-rouge">stage</code> can be 0 (experimental) to 4 (stable), or false. <code class="language-plaintext highlighter-rouge">Stage</code> 2 is the default.</p> <p>This preset-env plugin includes by default the Autoprefixer plugin and the browsers option will be passed to it automatically.</p> <h3 id="postcss-nested">PostCSS Nested</h3> <p>If we want only to use the nesting feature, then this plugin is the perfect choice as it produce the same result as the previous plugin.</p> <h3 id="postcss-mixins">PostCSS Mixins</h3> <p>Mixins allow you to define styles that can be re-used throughout your code.</p> <h3 id="stylelint">Stylelint</h3> <p>This is a CSS linter that helps us avoid errors in our code before they break our User Interface (UI).</p> <h3 id="cssnano">Cssnano</h3> <p>This is a minifier used to reduce the final CSS file size as much as possible so your code is ready for a production environment.</p> <h2 id="references">References</h2> <ul> <li><a href="https://postcss.org/">PostCSS offical website</a></li> </ul>]]></content><author><name></name></author><category term="CSS"/><category term="CSS"/><category term="HTML"/><category term="SASS"/><summary type="html"><![CDATA[What is PostCSS]]></summary></entry><entry><title type="html">Next.js App Router Introduction</title><link href="https://benwzj.github.io/blog/2024/nextjs-router/" rel="alternate" type="text/html" title="Next.js App Router Introduction"/><published>2024-04-14T00:00:00+00:00</published><updated>2024-04-14T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/nextjs-router</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/nextjs-router/"><![CDATA[<h2 id="what-is-routing">What is Routing</h2> <p>Routing is the skeleton of every web application. It is refer to the structure of files and URL.</p> <figure> <picture> <img src="/assets/img/terminology-component-tree.avif" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/assets/img/terminology-url-anatomy.avif" class="img-fluid rounded z-depth-1" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="app-route-vs-page-route">App Route vs Page Route</h2> <ul> <li>Next.js doc divided into two parts: App Route and Page Route.</li> <li>In version 13, Next.js introduced App Router built on React Server Components, which supports shared layouts, nested routing, loading states, error handling, and more. New Project should use App Route.</li> <li>The App Router works in a directory named <code class="language-plaintext highlighter-rouge">app</code>. The Page Route works in a <code class="language-plaintext highlighter-rouge">pages</code> directory. They can work at the same time.</li> <li>App Route structure: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└── app
  ├── about
  │   └── page.tsx
  ├── globals.css
  ├── layout.tsx
  ├── login
  │   └── page.tsx
  ├── page.js 
  └── team
      └── route.tsx
</code></pre></div> </div> </li> <li>Page Route structure: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└── pages
  ├── about.tsx
  ├── index.tsx
  └── team.tsx
</code></pre></div> </div> </li> <li>In App Route, Components is Server Components by default; In Page Route, component isClient Components by default.</li> <li>In App Route, <code class="language-plaintext highlighter-rouge">fetch</code> function for data fetching; In Page Route, It is using <code class="language-plaintext highlighter-rouge">getServerSideProps</code>, <code class="language-plaintext highlighter-rouge">getStaticProps</code>, <code class="language-plaintext highlighter-rouge">getInitialProps</code>.</li> <li>In App Route, Layouts can be nested and dynamic; In Page Route, Layouts are static.</li> </ul> <h2 id="app-route-overview">App Route Overview</h2> <h3 id="file-conventions">File Conventions</h3> <p>Next.js provides a set of special files to create UI with specific behavior in nested routes:</p> <ul> <li><code class="language-plaintext highlighter-rouge">layout</code> Shared UI for a segment and its children</li> <li><code class="language-plaintext highlighter-rouge">page</code> Unique UI of a route and make routes publicly accessible</li> <li><code class="language-plaintext highlighter-rouge">loading</code> Loading UI for a segment and its children</li> <li><code class="language-plaintext highlighter-rouge">not-found</code> Not found UI for a segment and its children</li> <li><code class="language-plaintext highlighter-rouge">error</code> Error UI for a segment and its children</li> <li><code class="language-plaintext highlighter-rouge">global-error</code> Global Error UI</li> <li><code class="language-plaintext highlighter-rouge">route</code> Server-side API endpoint</li> <li><code class="language-plaintext highlighter-rouge">template</code> Specialized re-rendered Layout UI</li> <li><code class="language-plaintext highlighter-rouge">default</code> Fallback UI for Parallel Routes</li> </ul> <h3 id="component-hierarchy">Component Hierarchy</h3> <p>The React components defined in special files of a route segment are rendered in a specific hierarchy:</p> <ul> <li>layout.js</li> <li>template.js</li> <li>error.js (React error boundary)</li> <li>loading.js (React suspense boundary)</li> <li>not-found.js (React error boundary)</li> <li>page.js or nested layout.js</li> </ul> <h2 id="pages-and-layouts">Pages and Layouts</h2> <p>A page is UI that is unique to a route. You can define a page by default exporting a component from a <code class="language-plaintext highlighter-rouge">page.js</code> file.</p> <p>A layout is UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render. You can define a layout by default exporting a React component from a <code class="language-plaintext highlighter-rouge">layout.js</code> file. The component should accept a children prop that will be populated with a child layout (if it exists) or a page during rendering.</p> <h2 id="route-handler">Route Handler</h2> <h3 id="what-is-route-handler">What is Route Handler</h3> <p>Route Handlers allow you to create <strong>custom request handlers</strong> for a given route using the Web Request and Response APIs. Route Handlers need to be defined in a <strong><code class="language-plaintext highlighter-rouge">route.ts</code></strong> file inside the app directory.</p> <p>Basic Example:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// app/api/route.ts</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">GET</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://data.mongodb-api.com/...</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span><span class="p">,</span>
      <span class="dl">'</span><span class="s1">API-Key</span><span class="dl">'</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DATA_API_KEY</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">})</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">Response</span><span class="p">.</span><span class="nf">json</span><span class="p">({</span> <span class="nx">data</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now, any Get Request at route <code class="language-plaintext highlighter-rouge">api/</code> will be handled by the export function <code class="language-plaintext highlighter-rouge">GET()</code>.</p> <h3 id="features">Features</h3> <ul> <li>Route Handlers can be nested inside the app directory, similar to page.js and layout.js.</li> <li>Each route.js or page.js file takes over all HTTP verbs for that route. So they can’t be at same route segment.</li> <li>Route Handlers are cached by default when using the <code class="language-plaintext highlighter-rouge">GET</code> method with the Response object.</li> <li>In the old version, Next.js Page Route, it use “API Routes” to do the same job: providing a solution to build a public API.</li> </ul> <h3 id="what-you-can-do-with-route-handler">What you can do with Route Handler</h3> <ul> <li>You setup Revalidate Cached Data for a Route API.</li> <li>Route Handlers can be used with dynamic functions from Next.js, like cookies and headers.</li> <li>Redirects</li> <li>Support Dynamic Route Segments</li> <li>The request object passed to the Route Handler is a NextRequest instance, which has some additional convenience methods.</li> <li>Use Streaming with Large Language Models (LLMs), such as OpenAI, for AI-generated content.</li> <li>You can use Request Body FormData.</li> </ul> <h2 id="fqa">FQA</h2> <h3 id="how-to-create-dynamic-route-segments">How to create dynamic route segments?</h3>]]></content><author><name></name></author><category term="React"/><category term="React"/><category term="Next.js"/><category term="Router"/><summary type="html"><![CDATA[What is Routing]]></summary></entry><entry><title type="html">Agile Methodology</title><link href="https://benwzj.github.io/blog/2024/agile/" rel="alternate" type="text/html" title="Agile Methodology"/><published>2024-04-07T00:00:00+00:00</published><updated>2024-04-07T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/agile</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/agile/"><![CDATA[<h2 id="what-is-agile-methodology">What is Agile Methodology</h2> <p>The Agile methodology is a project management approach that involves breaking the project into phases, commonly known as sprints, and emphasizes continuous collaboration and improvement. Teams follow a cycle of planning, executing, and evaluating.</p> <figure> <picture> <img src="/assets/img/inline-agile-agile-methodology-1-2x.webp" class="img-fluid rounded z-depth-1" width="60%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="waterfall-model">Waterfall Model</h3> <p>Before the Agile come out, the common Software develop methodology is Waterfall Model.</p> <figure> <picture> <img src="/assets/img/waterfall_model.jpg" class="img-fluid rounded z-depth-1" width="60%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>There are a lot of drawback of the waterfall model. For exampel, When you add features or update features, it need a specific time which is called downtime. Any Change in Waterfall model contain high risk as changes include a new revised version of the entire software running the entire series steps. That is because Waterfall treat the whole product as a single unit.</p> <p>Many big company found it get much better when switch to Agile. Agile based products are developed by breaking the entire product process into microservices or phrases which is faster to execute and deploy change on the go. Providing beta version to end users for reviewing is one of methods.</p> <h3 id="terminology">Terminology</h3> <p>Agile is a set of principles and <strong>Scrum</strong> is a framework for getting s#it done.<br/> The <strong>Manifesto</strong> itself was born out of a need to find a common ground among Scrum, Extreme Programming, Crystal Clear, and other frameworks.</p> <h2 id="agile-manifesto">Agile Manifesto</h2> <p>In early 2001, Utah, 17 people met to discuss the future of software development. The problem, they agreed, was that companies were so focused on excessively planning and documenting their software development cycles that they lost sight of what really mattered — <strong>pleasing their customers</strong>.</p> <p>The Agile Manifesto emerged from this extended weekend at just 68 words.</p> <h3 id="4-pillars-of-agile">4 pillars of Agile</h3> <p>As outlined in the Agile Manifesto, there are four main values of Agile project management:</p> <ul> <li><strong>Individuals over processes and tools</strong>: Agile teams value team collaboration and teamwork over working independently and doing things “by the book.”</li> <li><strong>Working software over comprehensive documentation</strong>: The software that Agile teams develop should work. Additional work, like documentation, is not as important as developing good software.</li> <li><strong>Customer collaboration over contract negotiation</strong>: Customers are extremely important within the Agile methodology. Agile teams allow customers to guide where the software should go. Therefore, customer collaboration is more important than the finer details of contract negotiation.</li> <li><strong>Responding to change over following a plan</strong>: One of the major benefits of Agile project management is that it allows teams to be flexible. This framework allows for teams to quickly shift strategies and workflows without derailing an entire project.</li> </ul> <h3 id="12-principles-behind-the-agile-manifesto">12 Principles behind the Agile Manifesto</h3> <ul> <li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li> <li>Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.</li> <li>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li> <li>Business people and developers must work together daily throughout the project.</li> <li>Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li> <li>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li> <li>Working software is the primary measure of progress.</li> <li>Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li> <li>Continuous attention to technical excellence and good design enhances agility.</li> <li>Simplicity–the art of maximizing the amount of work not done–is essential.</li> <li>The best architectures, requirements, and designs emerge from self-organizing teams.</li> <li>At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.</li> </ul> <h2 id="scrum">Scrum</h2> <p>Scrum is a lightweight framework that helps people, teams and organizations generate value through adaptive solutions for complex problems.</p> <p>In a nutshell, Scrum requires a Scrum Master to foster an environment where:</p> <ul> <li>A Product Owner orders the work for a complex problem into a Product Backlog.</li> <li>The Scrum Team turns a selection of the work into an Increment of value during a Sprint.</li> <li>The Scrum Team and its stakeholders inspect the results and adjust for the next Sprint.</li> <li>Repeat</li> </ul> <p>Scrum is simple.</p> <h3 id="terminology-1">Terminology</h3> <h4 id="sprint">Sprint</h4> <p>A sprint is a short, time-boxed period when a scrum team works to complete a set amount of work. Sprints help teams follow the agile principle of “delivering working software frequently,” as well as live the agile value of “responding to change over following a plan.” The scrum values of transparency, inspection, and adaptation are complementary to agile and central to the concept of sprints.</p> <ul> <li>Sprint planning: This event kicks off the sprint. Sprint planning outlines what can be delivered in a sprint (and how).</li> <li> <p>Daily Scrum: Scrum teams meet daily to discuss active tasks, roadblocks, and anything else that may affect the development team. Get everyone on the same page.</p> </li> <li>Sprint Review:</li> <li>Sprint retrospective: This recurring meeting acts as a sprint review—to iterate on learnings from a previous sprint that will improve and streamline the next one.</li> </ul> <p>Product backlog Sprint backlog</p> <h3 id="scrum-roles">Scrum Roles</h3> <h3 id="scrum-artifaces">Scrum Artifaces</h3> <h2 id="kanban">Kanban</h2> <p>Kanban is a visual approach to Agile. Teams use online Kanban board tools to represent where certain tasks are in the development process. Tasks are represented by cards on a board, and stages are represented in columns. As team members work on tasks, they move cards from the backlog column to the column that represents the stage the task is in.</p> <p>This method is a good way for teams to identify roadblocks and to visualize the amount of work that’s getting done.</p> <h2 id="extreme-programming-xp">Extreme Programming (XP)</h2> <p>Typically used in software development, Extreme Programming (XP) is an Agile framework that outlines values that will allow your team to work together more effectively.</p> <p>The five values of XP include:</p> <ul> <li>Communication</li> <li>Simplicity</li> <li>Feedback</li> <li>Courage</li> <li>Respect</li> </ul> <p>Similar to daily Scrum standups, there are regular releases and iterations, yet XP is much more technical in its approach. If your dev team needs to quickly release and respond to customer requests, XP focuses on the “how” it will get done.</p> <h2 id="references">References</h2> <ul> <li><a href="https://scrumguides.org/scrum-guide.html">scrum-guide</a></li> <li><a href="https://www.atlassian.com/agile/scrum">atlassian agile scrum</a></li> </ul>]]></content><author><name></name></author><category term="Programming"/><category term="Agile"/><summary type="html"><![CDATA[What is Agile Methodology]]></summary></entry><entry><title type="html">Rendering Process in React</title><link href="https://benwzj.github.io/blog/2024/react-render/" rel="alternate" type="text/html" title="Rendering Process in React"/><published>2024-04-04T00:00:00+00:00</published><updated>2024-04-04T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/react-render</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/react-render/"><![CDATA[<p>Even a component render, don’t means browser will repaint it. we get component, then component instance, then element, then VDOM, then DOM.</p> <h2 id="component-rendering-process">Component Rendering Process</h2> <p>Before your components are displayed on screen, they must be rendered by React.</p> <p>There are 3 steps for the whole rendering process:</p> <ol> <li>Triggering a render.</li> <li><strong>Rendering the component.</strong></li> <li>Committing to the DOM.</li> </ol> <h3 id="step-1-trigger-a-render">Step 1: Trigger a render</h3> <p>There are two reasons for a component to render:</p> <ul> <li>It’s the component’s initial render. By calling <code class="language-plaintext highlighter-rouge">createRoot</code> with the target DOM node, and then calling its render method with the component.</li> <li>The component’s (or one of its ancestors’) state has been updated. Updating the component’s state automatically queues a render. When prop or context be changed, it cause re-render as well.</li> </ul> <h3 id="step-2-react-renders-your-components">Step 2: React renders your components</h3> <blockquote class="block-warning"> <p>‘Rendering’ is React calling your components.</p> </blockquote> <ul> <li>On initial render, React will call the root component.</li> <li>For subsequent renders, React will <strong>call the function component</strong> whose state update triggered the render.</li> </ul> <blockquote class="block-warning"> <p>The default behavior of rendering will render all components nested within the updated component.</p> </blockquote> <p>This might be not optimal for performance if the updated component is very high in the tree. You can use <code class="language-plaintext highlighter-rouge">memo</code> and <code class="language-plaintext highlighter-rouge">useMemo</code> to avoid re-render the child components.</p> <h3 id="step-3-react-commits-changes-to-the-dom">Step 3: React commits changes to the DOM</h3> <p>After rendering (calling) your components, React will modify the DOM.</p> <ul> <li>For the initial render, React will use the appendChild() DOM API to put all the DOM nodes it has created on screen.</li> <li>For re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.</li> </ul> <p>React only changes the DOM nodes if there’s a difference between renders.</p> <p>After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion with React rendering.</p> <h2 id="check-if-component-is-re-rendered">Check if component is re-rendered</h2> <p>Re-render a component, means React execute that component function to calculate the output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">count</span><span class="o">++</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">component render number: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">count</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div> <p>But the component might be only invoked without rerendering. For example, you <code class="language-plaintext highlighter-rouge">setState()</code> to the same value as previous one, React will run the component function, but without rendering the children or firing effects.</p> <p>So the better way is to make a <code class="language-plaintext highlighter-rouge">useEffect</code> hook without a dependency array, this will make it run after each component render. Like code below can flicker the background when re-rendering:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// animation part</span>
  <span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">element</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent-flicker</span><span class="dl">"</span><span class="p">);</span>

    <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">element</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="dl">"</span><span class="s2">parent-flicker</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">200</span><span class="p">);</span>
  <span class="p">});</span>
</code></pre></div></div> <h2 id="display-render-count-in-component">Display render count in component</h2> <p>You can’t use State, but you can use <strong>Ref</strong>!!</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="nx">props</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">renderCounter</span>  <span class="o">=</span> <span class="nf">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nf">useEffect </span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
      <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="na">Renders</span><span class="p">:</span> <span class="p">{</span><span class="nx">renderCounter</span><span class="p">.</span><span class="nx">current</span><span class="p">},</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">};</span>
</code></pre></div></div> <h2 id="avoid-re-rendering-child-component">Avoid re-rendering child component</h2> <p>How to avoid re-rendering a nested child component when a parent component re-renders?</p> <h3 id="use-memory-api">Use Memory API</h3> <p>The basic way is using <code class="language-plaintext highlighter-rouge">React.memo</code> API. This can tell React avoid re-rendering child components. Most of the time you will use Hook <code class="language-plaintext highlighter-rouge">useMemo</code> and <code class="language-plaintext highlighter-rouge">useCallback</code> as well. More inforamtion at <a href="/blog/2023/memo-react/">Use Memory in React</a>.</p> <h3 id="lifting-content-up">lifting content up</h3> <p>The pattern of “lifting content up” has been used to avoid re-rendering a nested child component when a parent component re-renders. lifting content up means wrapping child component as <code class="language-plaintext highlighter-rouge">prop</code> and pass to parent component!</p> <h3 id="stop-re-rendering-of-child-which-consume-context">Stop re-rendering of child which consume Context</h3> <p>If context change, child should re-render. but if context don’t change, how to stop re-rendering? using <code class="language-plaintext highlighter-rouge">React.memo</code> API!</p> <h3 id="why-memory-function-can-stop-re-rendering">Why Memory function can stop re-rendering?</h3> <p>Because React is using <code class="language-plaintext highlighter-rouge">Object.is()</code> to make decision rendering or not.</p> <p>Memo function is used to memoize the result of the component. It returns the cached result when the same output occurs again. It will keep track of the previous <strong>prop’s value</strong> and compare it with the current value. If it detects changes, it will execute the child component again and re-evaluate it; if not, it will not execute it at all.</p> <h2 id="rendering-underhood">Rendering Underhood</h2> <h3 id="react-element">React Element</h3> <p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ele1</span> <span class="o">=&lt;</span><span class="nx">h1</span><span class="o">&gt;</span> <span class="nx">Hello</span><span class="p">,</span> <span class="nx">GFG</span> <span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="c1">// OR</span>
<span class="kd">const</span> <span class="nx">ele1</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">h1</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="nx">props</span><span class="p">},</span> <span class="dl">"</span><span class="s2">Hello, GFG</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">React.createElement()</code> function returns an object:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">h1</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hey Geek</span><span class="dl">'</span><span class="p">,</span>
            <span class="nx">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">header</span><span class="dl">'</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Normally, React elements is returned from React components. React don’t reuse element, it always destroy it and recreate it.</p> <h3 id="rendering-an-element-into-the-dom">Rendering an Element into the DOM</h3> <ul> <li>To Render an Element into the DOM, You need a root DOM node. <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">ReactDOM</span><span class="p">.</span><span class="nf">createRoot</span><span class="p">(</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">)</span>
<span class="p">);</span>
<span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">world</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="nx">root</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>To update the UI is to create a new element, and pass it to <code class="language-plaintext highlighter-rouge">root.render()</code>.</li> <li>ReactDom and React are same lib at version 13. React seperate them in order to support mare media, like ReactNative.</li> </ul> <h3 id="reconciliation">Reconciliation</h3> <p>Reconciliation is responsible for maintaining the tree of elements when a components prop or state change. Reconciliation houses the diffing algorithm that determines what parts of that tree need to be replaced.</p> <p>Here are some examples.</p> <ul> <li>When the React element’s type changed, React builds a whole new tree from scratch.</li> <li>React treat DOM element and component element differently.</li> <li>For children, like list, if you insert item at the end, React will check from the start and find it is same, the second is same and so on till the last one. And it will just add one item simply. BUT, if add item at start or middle, it can be expensive! React check the first one and find the difference, then it will destroy it and build new one, and second one is different and so on. It will destroy all and build again. So, React introduce <strong>key</strong> prop!</li> </ul> <h3 id="react-fiber">React Fiber</h3> <p>The actual rendering process is done by Ract Fiber.</p> <h2 id="fqa">FQA</h2> <ul> <li>How React render component with <code class="language-plaintext highlighter-rouge">key</code>?</li> <li>When re-render the component, is it means browser will re-paint the component? NO</li> </ul>]]></content><author><name></name></author><category term="React"/><category term="React"/><category term="Rendering"/><summary type="html"><![CDATA[Even a component render, don’t means browser will repaint it. we get component, then component instance, then element, then VDOM, then DOM.]]></summary></entry><entry><title type="html">Undterstand Server Component</title><link href="https://benwzj.github.io/blog/2024/server-component/" rel="alternate" type="text/html" title="Undterstand Server Component"/><published>2024-04-04T00:00:00+00:00</published><updated>2024-04-04T00:00:00+00:00</updated><id>https://benwzj.github.io/blog/2024/server-component</id><content type="html" xml:base="https://benwzj.github.io/blog/2024/server-component/"><![CDATA[<p>When we talk about Server Components and Client Components, it is from the view of Rendering.</p> <p>In Next.js App Route, all components in the App Router are Server Components <strong>by default</strong>!</p> <p>Router is the skeleton of the whole Next.js Application. It can decide HOW to <strong>render</strong> Server Components and Client Components.</p> <h2 id="foundational-web-concepts">Foundational web concepts</h2> <ul> <li>The <strong>Environments</strong> your application code can be executed in: the server and the client.</li> <li>The <strong>Request-Response Lifecycle</strong> that’s initiated when a user visits or interacts with your application.</li> <li>The <strong>Network Boundary</strong> that separates server and client code.</li> </ul> <h3 id="rendering-environments">Rendering Environments</h3> <p>There are two environments where web applications can be rendered: the client and the server.</p> <p>Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use the same language (JavaScript), and the same framework (e.g. Next.js or your framework of choice). This flexibility allows you to seamlessly write code for both environments without context switching.</p> <p>However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is not always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment over the other.</p> <h3 id="network-boundary">Network Boundary</h3> <p>In web development, the Network Boundary is a conceptual line that separates the different environments. For example, the client and the server, or the server and the data store.</p> <p>In React, you choose where to place the client-server network boundary wherever it makes the most sense.</p> <p>Behind the scenes, the work is split into two parts: the client module graph and the server module graph. The server module graph contains all the components that are rendered on the server, and the client module graph contains all components that are rendered on the client.</p> <p>It may be helpful to think about module graphs as a visual representation of how files in your application depend on each other.</p> <p>You can use the React <code class="language-plaintext highlighter-rouge">"use client"</code> convention to define the boundary. There’s also a <code class="language-plaintext highlighter-rouge">"use server"</code> convention, which tells React to do some computational work on the server.</p> <h3 id="building-hybrid-applications">Building Hybrid Applications</h3> <p>When working in these environments, it’s helpful to think of the flow of the code in your application as <strong>unidirectional</strong>. If you need to access the server from the client, you send a new request to the server rather than re-use the same request. This makes it easier to understand where to render your components and where to place the Network Boundary.</p> <p>In practice, this model encourages developers to think about what they want to execute on the server first, before sending the result to the client and making the application interactive.</p> <h2 id="react-server-components">React Server Components</h2> <h3 id="server-rendering">Server Rendering</h3> <p>React Server Components allow you to write UI that can be rendered and optionally cached on the server. In short, Server Components allow you to do <strong>Server Rendering</strong>.</p> <h4 id="benefits-of-server-rendering">Benefits of Server Rendering</h4> <ul> <li>Data Fetching: Server Components allow you to move data fetching to the server.</li> <li>Security: Server Components allow you to keep sensitive data and logic on the server.</li> <li>Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users.</li> <li>Performance: Server Components give you additional tools to optimize performance.</li> <li>Initial Page Load and First Contentful Paint (FCP).</li> <li>Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots.</li> <li>Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.</li> </ul> <h3 id="how-are-server-components-rendered-in-nextjs">How are Server Components rendered in Next.js</h3> <p>Next.js uses Server Components by default. This allows you to automatically implement server rendering with no additional configuration, and you can opt into using Client Components when needed.</p> <p>On the server, Next.js uses React’s APIs to orchestrate rendering. The rendering work is split into chunks:</p> <ul> <li>by individual route segments and</li> <li>Suspense Boundaries.</li> </ul> <p>Each chunk is rendered in two steps:</p> <ol> <li>React renders Server Components into a special data format called the React Server Component Payload (<strong>RSC Payload</strong>).</li> <li>Next.js uses the RSC Payload and Client Component JavaScript instructions to render HTML on the server.</li> </ol> <p>Then, on the client:</p> <ol> <li>The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.</li> <li>The RSC Payload is used to reconcile the Client and Server Component trees, and update the DOM.</li> <li>The JavaScript instructions are used to <strong>hydrate</strong> Client Components and make the application interactive.</li> </ol> <h3 id="what-is-hydration">What is Hydration</h3> <p>In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.</p> <p>For example, Call <code class="language-plaintext highlighter-rouge">hydrate</code> to attach a React component into a server-rendered browser DOM node:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">hydrate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-dom</span><span class="dl">'</span><span class="p">;</span>
<span class="nf">hydrate</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">App</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div></div> <h3 id="what-is-the-react-server-component-payload-rsc-payload">What is the React Server Component Payload (RSC Payload)?</h3> <p>The RSC Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the client to update the browser’s DOM. The RSC Payload contains:</p> <ul> <li>The rendered result of Server Components</li> <li>Placeholders for where Client Components should be rendered and references to their JavaScript files</li> <li>Any props passed from a Server Component to a Client Component</li> </ul> <h3 id="server-rendering-strategies">Server rendering strategies</h3> <p>In Next.js, the rendering work is further split by route segments to enable streaming and partial rendering.</p> <p>There are three subsets of server rendering: Static, Dynamic, and Streaming.</p> <h4 id="static-rendering-default">Static Rendering (Default)</h4> <p>With Static Rendering, routes are rendered at build time, or in the background after data revalidation. The result is cached and can be pushed to a Content Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests.</p> <h4 id="dynamic-rendering">Dynamic Rendering</h4> <p>With Dynamic Rendering, routes are rendered for each user at request time.</p> <p>Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL’s search params.</p> <p>In most websites, routes are not fully static or fully dynamic - it’s a spectrum.</p> <p>In Next.js, you can have dynamically rendered routes that have both cached and uncached data. This is because the RSC Payload and data are cached separately. This allows you to opt into dynamic rendering without worrying about the performance impact of fetching all the data at request time.</p> <p>During rendering, if a <code class="language-plaintext highlighter-rouge">dynamic function</code> or <code class="language-plaintext highlighter-rouge">uncached data request</code> is discovered, Next.js will switch to dynamically rendering the whole route.</p> <p>In Next.js, these dynamic functions are:</p> <ul> <li>cookies() and headers(): Using these in a Server Component will opt the whole route into dynamic rendering at request time.</li> <li>searchParams: Using the searchParams prop on a Page will opt the page into dynamic rendering at request time.</li> </ul> <h4 id="streaming">Streaming</h4> <p>Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.</p> <p>Streaming is built into the Next.js App Router by default. This helps improve both the initial page loading performance, as well as UI that depends on slower data fetches that would block rendering the whole route.</p> <h3 id="use-server-component">Use Server component</h3> <ul> <li>You don’t need to use <code class="language-plaintext highlighter-rouge">"use server"</code> to write Server component. Just ust <code class="language-plaintext highlighter-rouge">"use server"</code> to export server atction.</li> </ul> <h2 id="client-components">Client Components</h2> <p>Client Components allow you to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser.</p> <h3 id="client-rendering">Client Rendering</h3> <p>Benefits of Client Rendering</p> <ul> <li>Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.</li> <li>Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage.</li> </ul> <h3 id="using-client-components">Using Client Components</h3> <p>To use Client Components, you can add the React <code class="language-plaintext highlighter-rouge">"use client"</code> directive at the top of a file, above your <code class="language-plaintext highlighter-rouge">imports</code>.</p> <p><code class="language-plaintext highlighter-rouge">"use client"</code> is used to declare a boundary between a Server and Client Component modules. This means that by defining a <code class="language-plaintext highlighter-rouge">"use client"</code> in a file, all other modules imported into it, including child components, are considered part of the client bundle.</p> <p>You can define multiple <code class="language-plaintext highlighter-rouge">"use client"</code> <strong>entry points</strong> in your React Component tree. This allows you to split your application into multiple client bundles.</p> <p>However, <code class="language-plaintext highlighter-rouge">"use client"</code> doesn’t need to be defined in every component that needs to be rendered on the client. For example, when you import a component into a client component, that component will be treated as client component. Once you define the boundary, all child components and modules imported into it are considered part of the client bundle.</p> <blockquote class="block-warning"> <p>All components are considered as Server components first until you use <code class="language-plaintext highlighter-rouge">"use client"</code> to define the boundary. You should have a clear mind when you define the boundary because the client components are the less the better.</p> </blockquote> <h4 id="recap">Recap</h4> <ul> <li>Once you define the boundary, all child components and modules <strong>imported</strong> into it are considered part of the client bundle. But Server component can live inside Client component as <strong>children</strong>. The classic example is that context component, which can be client component, can wrap server component.</li> <li>All hooks, state management (Context API, Zustand, Redux) just use in Client components.</li> <li><code class="language-plaintext highlighter-rouge">async/await </code>is not support in client components, only in server components in Next.js.</li> <li>client components don’t just run in the client. They will run once in the server for the initial rendering! So if you visit Browser API, like <code class="language-plaintext highlighter-rouge">localStorage</code>, you may get errors. So it is better to use code like this: <code class="language-plaintext highlighter-rouge">if (typeof(window !=== undefined)) { window.localStorage()...}</code> to protect it. React won’t run hook in initial rendering because React know that things.</li> <li>In server component, if you use a component which use Hooks or Browser API, and that component don’t use <code class="language-plaintext highlighter-rouge">"use client"</code>, it will cause errors. In this case, you just need to add <code class="language-plaintext highlighter-rouge">'use client'</code>. If that component is 3rd lib, you can wrap it in a separate component and add <code class="language-plaintext highlighter-rouge">'use client'</code>.</li> </ul> <h3 id="how-are-client-components-rendered">How are Client Components Rendered</h3> <p>There can be two ways:</p> <ul> <li>Full page load: To optimize the initial page load, Next.js will use React’s APIs to render a static HTML preview on the server for both Client and Server Components. And then React will do a process which is called <strong>hydration</strong>.</li> <li>Subsequent Navigations: Client Components are rendered entirely on the client, without the server-rendered HTML.</li> </ul> <h3 id="going-back-to-the-server-environment">Going back to the Server Environment</h3> <p>Sometimes, after you’ve declared the “use client” boundary, you may want to go back to the server environment.</p> <p>You can keep code on the server even though it’s theoretically nested inside Client Components by <strong>interleaving</strong> Client and Server Components and Server Actions.</p> <h2 id="composition-patterns">Composition Patterns</h2> <p>Need to have a clear mind what server component, client component should do, and can do! Use Server Component when:</p> <ul> <li>Fetch data</li> <li>Access backend resources (directly)</li> <li>Keep sensitive information on the server (access tokens, API keys, etc)</li> <li>Keep large dependencies on the server / Reduce client-side JavaScript</li> </ul> <p>Use Client Component when:</p> <ul> <li>Add interactivity and event listeners (onClick(), onChange(), etc)</li> <li>Use State and Lifecycle Effects (useState(), useReducer(), useEffect(), etc)</li> <li>Use browser-only APIs</li> <li>Use custom hooks that depend on state, effects, or browser-only APIs</li> </ul> <h3 id="server-component-patterns">Server Component Patterns</h3> <p>Here are some common patterns when working with Server Components:</p> <h4 id="sharing-data-between-components">Sharing data between components</h4> <p>Instead of using React Context or passing data as props, you can use <code class="language-plaintext highlighter-rouge">fetch</code> or React’s <code class="language-plaintext highlighter-rouge">cache</code> function to fetch the same data in the components. React extends <code class="language-plaintext highlighter-rouge">fetch</code> to automatically memoize data requests.</p> <h4 id="keeping-server-only-code-out-of-the-client-environment">Keeping Server-only Code out of the Client Environment</h4> <p>You may keep some module just only available for server component. For example, the component is using some sensitive data, like <code class="language-plaintext highlighter-rouge">API_KEY</code>, to fetch data. You can use <code class="language-plaintext highlighter-rouge">import 'server-only'</code> to give other developers a build-time error if they ever accidentally import one of these modules into a Client Component.</p> <h4 id="using-third-party-packages-and-providers">Using Third-party Packages and Providers</h4> <p>When you use Third-party Packages in your server component, and these Packages are using some Client only API, you will get some error. The simply way to fix this error is telling Next.js that, this part of code is render as client component by wrap it into a file with <code class="language-plaintext highlighter-rouge">"use client"</code>.</p> <p>When use Context Providers in your server component, it is same way to deal with it: mark it as a Client Component: Wrap these Providers into a file with <code class="language-plaintext highlighter-rouge">"use client"</code>.</p> <h3 id="client-components-patterns">Client Components Patterns</h3> <p>To reduce the Client JavaScript bundle size, Next.js recommend moving Client Components down your component tree. That means try to keep all your components as server components if it can be.</p> <h4 id="passing-props-from-server-to-client-components-serialization">Passing props from Server to Client Components (Serialization)</h4> <p>If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to be serializable by React.</p> <p>If your Client Components depend on data that is not serializable, you can fetch data on the client with a third party library or on the server via a Route Handler.</p> <h3 id="interleaving-patterns">Interleaving Patterns</h3> <p>You should visualize your UI as a tree of components. Starting with the root layout, which is a Server Component, you can then render certain subtrees of components on the client by adding the “use client” directive.</p> <p>Within those client subtrees, you can still nest Server Components or call Server Actions, however there are some things to keep in mind:</p> <ul> <li>During a request-response lifecycle, your code moves from the server to the client. If you need to access data or resources on the server while on the client, you’ll be making a new request to the server - not switching back and forth.</li> <li>When a new request is made to the server, all Server Components are rendered first, including those nested inside Client Components. The rendered result (RSC Payload) will contain references to the locations of Client Components. Then, on the client, React uses the RSC Payload to reconcile Server and Client Components into a single tree.</li> <li>Since Client Components are rendered after Server Components, you cannot import a Server Component into a Client Component module (since it would require a new request back to the server). Instead, you can pass a Server Component as props to a Client Component.</li> </ul> <blockquote class="block-warning"> <p>The pattern of “lifting content up” has been used to avoid re-rendering a nested child component when a parent component re-renders.</p> </blockquote> <h2 id="fqa">FQA</h2> <ul> <li>How do Server and Client component communicate? What kind of protocal? and How?</li> <li>How do React know a component is Server component or Client component?</li> <li>How do Next.js know what codes need to be bundle and send to browser when Client and Server Components are interleaving together?</li> <li>How do React and Next.js connect together?</li> </ul>]]></content><author><name></name></author><category term="React"/><category term="React"/><category term="Next.js"/><category term="Router"/><category term="Rendering"/><summary type="html"><![CDATA[When we talk about Server Components and Client Components, it is from the view of Rendering.]]></summary></entry></feed>