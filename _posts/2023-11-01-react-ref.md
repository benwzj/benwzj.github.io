---
layout: post
title: Ref in React
date: 2023-11-01
category: React
tags: React Ref
---

## What is Refs

> ##### The Definition
> 
> When you want a component to “remember” some information, but you don’t want that information to trigger new renders, you can use a `ref`.
{: .block-warning }

You can access the current value of that ref through the `ref.current` property. This value is intentionally mutable, meaning you can both read and write to it. It’s like a secret pocket of your component that React doesn’t track. (This is what makes it an “escape hatch” from React’s one-way data flow—more on that below!)

### Ref vs State

- `state` and `ref` could point to anything: a string, an object, or even a function. 
- `state` and `refs` both are live outside of your component.
- `state` and `refs` both are retained by React between re-renders. 
- Mutating `state` cause re-render. Mutating `ref` won't.
- `state` works as snapshot for each render, You can't get latest state from an asynchronous operation; But `ref` won't be affected by render, you can read the latest ref anytime.
- `state` is ”Immutable” — you must use the state setting function to modify state variables to queue a re-render; `ref` is mutable, it is a **plain** JavaScript object that you can read and modify.
- You shouldn’t read (or write) the `ref.current` value during rendering. But You can read `state` any time. 

## Using `ref`

### Example: alerting how many click have happen.
```js
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

### DebouncedButton component

If you keep clicking the button, it will ignore the click event, untill you stop and wait a second. This is called **Debounced**. `ref` is good way to implement this:
```js
import {useRef} from 'react';

function DebouncedButton({ onClick, children }) {
  const timeoutID = useRef(null);
  return (
    <button onClick={() => {
      clearTimeout(timeoutID.current);
      timeoutID.current = setTimeout(() => {
        onClick();
      }, 1000);
    }}>
      {children}
    </button>
  );
}
```

## When to use refs 

Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:

- Storing and manipulating **DOM elements** (the most common use case).
- Storing **timeout IDs**
- Storing other objects that aren’t necessary to calculate the JSX.

If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs.

## Best practices for refs 
Following these principles will make your components more predictable:

- **Treat refs as an escape hatch**. Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.
- **Don’t read or write `ref.current` during rendering**. If some information is needed during rendering, use state instead. Since React doesn’t know when `ref.current` changes, even reading it while rendering makes your component’s behavior difficult to predict. (The only exception to this is code like `if (!ref.current) ref.current = new Thing()` which only sets the ref once during the first render.)

## Manipulating the DOM with Refs

React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. **However**, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node.

For example, this is handy if you want to focus an input programmatically. When you pass a ref to a `ref` attribute in JSX, like `<div ref={myRef}>`, React will put the corresponding DOM element into myRef.current. Once the element is removed from the DOM, React will update `myRef.current` to be null. 

### Getting a ref to the node

To access a DOM node managed by React: 
- first, import the useRef Hook:
`import { useRef } from 'react';`
- Then, use it to declare a ref inside your component:
`const myRef = useRef(null);`
- Finally, pass your `ref` as the `ref` attribute to the JSX tag for which you want to get the DOM node:
`<div ref={myRef}>`

The `useRef` Hook returns an object with a single property called current. Initially, `myRef.current` will be `null`.

When React creates a DOM node for this` <div>`, React will put a reference to this node into `myRef.current`. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.
Then:
```js
// You can use any browser APIs, for example:
myRef.current.scrollIntoView();
```

## `ref` callback

Sometimes you might need a `ref` to each item in the list, and you don’t know how many you will have.

`ref` callback can let you manage a list of refs! 

The idea is like this:
`ref` doesn’t hold a single DOM node. Instead, it holds a Map from item ID to a DOM node. The ref callback on every list item takes care to update the Map.
You can pass a function to the `ref` attribute. And then React will call your `ref` callback with the DOM node when it’s time to set the `ref`, and with null when it’s time to clear it. This lets you maintain your own array or a Map, and access any `ref` by its index or some kind of ID.



## Reference

[React official doc](https://react.dev/learn/referencing-values-with-refs)
