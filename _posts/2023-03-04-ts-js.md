---
layout: post
title: TS sit on JS 
date: 2023-03-04
tags: TypeScript JavaScript 
category: JavaScript
---

This is for the one who are enperienced in JS but new for TS.

## TS Overview

TS is **SuperSet** of JS.
TS is JS with syntax for types.
TS need to be compiled.
You can say TS is a compiler, can replace Babel.
The main point of TS compiler is providing Type Check.
TS provide more semantics.
TS have a big community.
TS is known as an Object-oriented programming language whereas JS is a prototype-based language.

Benefit From TS:

- Good for large project. 
- Refactoring
- Code completion
- Static typing
- Shorthand notations

## TypeScript’s type system.

TypeScript will generate types for you in many cases. 
For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.
```ts
let helloWorld = "Hello World";
let helloWorld: string
```

But some design patterns make it difficult for types to be inferred automatically. 
TS provide extension for that, like **Interface**.

### Structural Type System

One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.

In a structural type system, if two objects have the same shape, they are considered to be of the same type

## Interface

For example, You can explicitly describe this object’s shape using an interface declaration.
```ts
interface User {
  name: string;
  id: number;
}
```
Now, you can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:
```ts
const user: User = {
  name: "Hayes",
  id: 0,
};
```

Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:
```ts
interface User {
  name: string;
  id: number;
}
 
class UserAccount {
  name: string;
  id: number;
 
  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}
 
const user: User = new UserAccount("Murphy", 1);
```

You can use interfaces to annotate parameters and return values to functions:
```ts
function deleteUser(user: User) {
  // ...
}
 
function getAdminUser(): User {
  //...
}
```

There is already a small set of primitive types available in JavaScript: **boolean**, __bigint__, **null**, **number**, **string**, **symbol**, and **undefined**, which you can use in an interface. TypeScript extends this list with a few more, such as **any** (allow anything), **unknown** (ensure someone using this type declares what the type is), **never** (it’s not possible that this type could happen), and **void** (a function which returns undefined or has no return value).

## Composing Types

With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with **unions**, and with **generics**.

### Union
A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:
```ts
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

### Generic
Generics provide variables to types by using angle bracket. 

A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.
For example: 
```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;
```

You can declare your own types that use generics:
``` ts
interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}

// This line is a shortcut to tell TypeScript there is a
// constant called `backpack`, and to not worry about where it came from.
declare const backpack: Backpack<string>;
 
// object is a string, because we declared it above as the variable part of Backpack.
const object = backpack.get();
 
// Since the backpack variable is a string, you can't pass a number to the add function.
backpack.add(23);
```
> Argument of type 'number' is not assignable to parameter of type 'string'.
{: .block-danger }

## interfaces vs type aliases

There are two main tools to declare the shape of an object: interfaces and type aliases.
They are very similar, and for the most common cases act the same. And because TypeScript is a structural type system, it's possible to intermix their use.

### both support extending other interfaces and types.
Type aliases do this via intersection types, while interfaces have a keyword.

```ts
type BirdType = {
  wings: 2;
};

interface BirdInterface {
  wings: 2;
}
type Owl = { nocturnal: true } & BirdType;
type Robin = { nocturnal: false } & BirdInterface;

interface Peacock extends BirdType {
  colourful: true;
  flies: false;
}
interface Chicken extends BirdInterface {
  colourful: false;
  flies: false;
}

let owl: Owl = { wings: 2, nocturnal: true };
let chicken: Chicken = { wings: 2, colourful: false, flies: false };
```

But TypeScript recommend to use interfaces over type aliases. Specifically, because you will get better error messages. 

### interfaces are open and type aliases are closed. 
This means you can extend an interface by declaring it a second time. Interface can do this:

```ts
interface Kitten {
  purrs: boolean;
}

interface Kitten {
  colour: string;
}
```

For publicly exposed types, it's a better call to make them an interface.

### this stack overflow thread have more detail:
https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220

